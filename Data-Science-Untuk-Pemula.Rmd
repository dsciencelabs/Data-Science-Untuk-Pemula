--- 
title: "Data Science Untuk Pemula"
author: "Bakti Siregar S.Si, M.Sc"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: 
  bookdown::gitbook:
    config:
      toc:
        collapse: subsection
        scroll_highlight: yes
      fontsettings:
        theme: white
        family: serif
        size: 2
    split_by: chapter+number
    highlight: tango
always_allow_html: yes
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
biblatexoptions:
  - sortcites
link-citations: yes
github-repo: Bakti-Siregar/Data-Science-Untuk-Pemula
description: "Repository ini ditujukan untuk memudahkan penulisan e-book Data Science Untuk Pemula dalam bahasa Indonesia."
---

# {-}

```{r install-packages, include=FALSE}
# The **bookdown** package can be installed from CRAN or Github: 
# install.packages("bookdown")
# or the development version
# devtools::install_github("rstudio/bookdown")
```

```{r input-packages, include=FALSE}
# To compile this example to PDF, you need XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX):<https://yihui.name/tinytex/>.

# automatically create a bib database for R packages
knitr::write_bib(c(.packages(),
                   'bookdown', 
                   'knitr', 
                   'rmarkdown'
), 'packages.bib')
```

<center><img src="images/datascience1.png" style = "width:40%;"></center>
<br> 
<img style="float: right; margin: 0px 100px 0px 0px; width:40%" src="images/logomatana.png"/> 
Department of Statistics
<br> 
Faculty of STEM 
<br>
Tangerang, Banten 
<br> 
<a href="https://mail.google.com/siregarbakti/">Info: siregarbakti@gmail.com</a>
<br>
<br>

## Kata Pengantar {-}
Buku ini dimulai dari tingkat pengantar, kursus praktik langsung, dirancang untuk `orang-orang pintar` dengan latar belakang dasar matematika atau statistik, ekonometrik, dan ilmu komputer, bahkan tanpa pengalaman pemrograman. Ini akan memperkenalkan Anda pada berbagai perspektif ilmu data, termasuk pemrosesan data, analisis, visualisasi, dan pemodelan. Setiap bab secara praktis akan dibahas dalam RStudio Integrated Development Environment (IDE).

Seperti yang mungkin sudah Anda ketahui, sains data telah menggemparkan dunia. Setiap bidang studi dan bidang bisnis telah terpengaruh, karena orang semakin menyadari nilai dari kuantitas data yang begitu besar telah dihasilkan. Tetapi untuk mengubah nilai dari data tersebut, seseorang perlu dilatih dalam keterampilan sains data yang tepat. Bahasa pemrograman R telah menjadi salah satu yang paling terkenal untuk sains data. Bahasa pemrograman R memiliki fleksibilitas, kekuatan, kecanggihan, dan ekspresifnya telah menjadikannya alat yang tak ternilai bagi ilmuwan data di seluruh dunia.

Sebagian besar materi dalam buku ini diambil dari pengalaman mengajar saya di R dalam struktur data dan algoritme, statistik komputasi, dan sistem basis data dan tentu saja diadopsi secara menyeluruh dari berbagai tahap pengembangan. Beberapa diantaranya di dapatkan dari Coursera, Data Camp, Data Flair, R-tutorial, dll. Di sini, Anda akan belajar dari dasar-dasar pemrograman R, fungsi menulis, manipulasi data, teknik visualisasi, menangani debug, dan mengoptimalkan kode. Dengan pengalaman fundamental, Anda akan memiliki dasar yang kuat untuk membangun perjalanan sains data Anda. Jadi, nikmatilah buku ini, teruslah belajar, dan berlatihlah sebanyak yang Anda inginkan.

## Penulis {-}
Saya mulai menggunakan R pada tahun 2012 ketika saya masih menjadi mahasiswa sarjana perguruan tinggi yang saat itu sedang mengerjakan pekerjaan rumah mata kuliah Statistik Komputasi. Versi R yang saya gunakan waktu itu adalah 2.15.1. Saya adalah seorang mahasiswa jurusan matematika terapan dengan konsentrasi statistik. Setelah kuliah di bulan Oktober 2013, saya mendaftar di Management Trainee (MT) di Asuransi Sinar Mas sebagai Underwriter selama kurang lebih tiga bulan. Kemudian pindah ke proses pelatihan karyawan serupa yang disebut Office Deployment Program (ODP) di MPM Finance sebagai Credit Analyst (sekitar enam bulan). Setelah semua pengalaman ini, saya ingin meningkatkan studi saya ke jenjang berikutnya karena saya menganggap diri saya belum cukup baik untuk sukses dalam karir saya dengan pengetahuan yang terbatas ini. Oleh karena itu, selama mengikuti proses pelatihan, saya selalu berusaha mendaftar ke beberapa universitas luar negeri.

Pada bulan September 2014, saya beruntung karena saya mendapat kesempatan untuk melanjutkan gelar master saya di National Sun Yat-Sen University (Taiwan) dengan program beasiswa. Di Universitas ini, saya mendaftar di jurusan matematika terapan dengan konsentrasi statistik. Saya belajar banyak di kampus ini, mulai dari perspektif kehidupan, budaya, menghargai sesama, selalu tepat waktu, menambah ilmu statistika saya, dan sebagainya. Selama studi saya, saya bekerja dengan profesor saya sebagai asisten pengajar dan saya beruntung mendapatkan tunjangan tambahan. Untuk itu saya fokus mengajar, saya harus menghadiri Lab meeting kami satu atau dua kali seminggu, membantu acara-acara universitas, mengatur beberapa kegiatan trip, dan melakukan penelitian bersama (Prof. Mei-Hui Guo dan Prof. Chung Chang). Mereka menyarankan saya untuk belajar setidaknya dasar-dasar bahasa Mandarin untuk bertahan hidup di Taiwan dan harus meningkatkan kemampuan pemrograman saya dengan R, Python, SAS, dan MATLAB secara konsisten untuk menangani semua pekerjaan rumah saya juga.

Langkah selanjutnya dalam karir saya, saya masuk ke departemen teknik di PT Andalan Furnindo (Samora Group) sebagai seorang analis data. Ini merupakan salah satu industri gula terbaik di Indonesia, dimana saya berada di sini setidaknya selama satu tahun sejak 2017. Kemudian saya merasa bahwa tidak semua pengetahuan saya dapat berguna di perusahaan ini, bahkan tidak dapat mengembangkannya ke tingkat yang lebih baik. Maka dengan tantangan yang besar, saya memutuskan untuk pindah ke tempat baru yaitu Universitas Matana pada tahun 2018, di sini saya mulai mengabdikan diri dengan mengajar statistika bisnis dan terus berkembang dengan ilmu-ilmu baru. Di sini saya banyak belajar dan mengajar tentang sains data, saya fokus mengajar struktur data dan algoritma, sistem basis data, statistik komputasi, ekonometrika, deret waktu, kalkulus, optimasi, metode penelitian, dll. Yang terpenting, saya percaya diri untuk mengatakan bahwa saya memiliki kemampuan expert dengan beberapa bahasa pemrograman seperti R, Python, SQL, dll, dan saya juga memiliki kemampuan yang cukup baik untuk menggunakan Business Intelligence Tools, seperti Tableau dan SAS.

Bakti Siregar, M.Sc
<br>
Email: siregarbakti@gmail.com atau siregar.bakti@matanauniversity.ac.id
<br>
Github: https://github.com/Bakti-Siregar
<br>
LinkedIn: https://www.linkedin.com/in/bakti-siregar-15955480/

## Assistant {-}
Saya adalah mahasiswa Universitas Matana jurusan Statistika Bisnis angkatan 2018. Pertama kali saya belajar R adalah ketika saya memasuki perkuliahan di semester ke-3 pada mata kuliah Struktur Data dan Algoritma yang diajarkan oleh Bapak Bakti Siregar, M.Sc.

Juenzy Hodawya
<br>
Email: hodawya125@gmail.com atau juenzy.hodawya@matanauniversity.ac.id
<br>
Github: https://github.com/JuenzyHodawya
<br>
LinkedIn: https://www.linkedin.com/in/juenzy-hodawya-a310ab1a3/

<!--chapter:end:index.Rmd-->

# Pendahuluan {#Pendahuluan}
***


Disini di tuliskan materi

<!--chapter:end:01-Pendahuluan.Rmd-->

# Dasar-dasar R {#Dasar-R}
***

Mari kita mulai terlebih dahulu dengan dasar-dasar R. Jika Anda sudah memiliki pengalaman dengan R, Anda mungkin dapat melewati bagian ini. Saya sangat menyarankan Anda untuk bekerja dengan RStudio Integrated Development Environment (IDE). Pastikan juga Anda mengerti dua jenis file R:

*	`.R` file teks `ASCII` yang hanya berisi skrip R.
*	`.Rmd` file teks `ASCII`. Jika dibuka di RStudio dapat dijalankan sebagai R-Notebook atau dikompilasi menggunakan knitr, bookdown, dll.

## Operator Penugasan

Di sini saya merekapitulasi beberapa operator penugasan yang perlu Anda ketahui agar Anda terbiasa dengan kode R:

*	`<-` dikenal sebagai operator penugasan. Artinya, "Buat nama objek di sebelah kiri sama dengan output dari koding di sebelah kanan” 
*	`&` Berarti AND, dalam logika Boolean
*	`|` berarti OR, dalam logika Boolean.
*	`!` berarti NOT, dalam logika Boolean.
*	Ketika merujuk pada nilai yang dimasukkan sebagai teks, atau tanggal, masukkanlah dengan tanda kutip, seperti ini: "Amerika Serikat", atau "2016-07-26". Angka tidak dikutip.
*	Saat memasukkan dua atau lebih nilai sebagai daftar (list), gabungkanlah dengan menggunakan fungsi `c`, dengan nilai yang dipisahkan oleh koma, misalnya: `c ("2020-07-26", "2020-08-04")`.
*	Seperti dalam spreadsheet, Anda dapat menentukan rentang nilai dengan titik dua, misalnya: `c (1:10)`, fungsi ini menghasilkan daftar bilangan bulat dari satu hingga sepuluh.

Beberapa operator umum:

*	`+ -` tambah, kurang;
*	`* /` kali, bagi;
* `> <` lebih besar dari, kurang dari;
*	`>= <=` lebih besar dari atau sama dengan, kurang dari atau sama dengan;
*	`!=` tidak sama dengan.
*	Tanda sama dengan bisa sedikit membingungkan, tetapi lihat bagaimana mereka digunakan dalam kode yang kita gunakan hari ini:
* `==` menguji apakah suatu objek sama dengan nilai. Tanda Ini sering digunakan saat memfilter data;
*	`=` membuat objek sama dengan nilai; bekerja seperti `<-`, tetapi digunakan di dalam tanda kurung dari sebuah fungsi.
*	`$` untuk menentukan kolom individual dengan memisahkan nama frame data dan nama kolom.
**Catatan** Objek dan nama variabel dalam R tidak boleh berisi spasi.

## Kalkulator Sederhana Dalam R

Contoh	       Operator	       Syntax di R
------        ----------       ------------
5+5           	Tambah	            +
5-5	            Kurang             	-
5x5	            Kali	              *
5:5	            Bagi	              /
5^5	            Pangkat	            ^
√25	            Akar kuadrat	      sqrt
Log 5	          Logaritma	          log()
Exp 5	          Eksponensial	      exp()
(5/5)+5	        Tanda kurung	      ()


### Penugasan Variabel

Pertama, Anda harus menetapkan nilai ke variabel di konsol R Anda:

```{r, echo=T, results='hide'}
x <- 5              # memberikan nilai ke `x`             
y <- 5              # memberikan nilai ke `y`
```

Kemudian, jalankan kode berikut di bawah ini baris demi baris untuk melihat hasilnya:

```{r, echo=T, results='hide'}

x + y 			        # Tambah
x - y 			        # Pengurangan
x * y 			        # Perkalian
x / y 			        # Pembagian
x ^ y 			        # Pangkat
sqrt(x * y)	        # Akar kuadrat
log(x) 			        # Logaritma
exp(y) 			        # eksponensial
(x/y) + y 		      # Tanda Kurung
```

Anda juga bisa melakukan perhitungan menggunakan nama variabel:

```{r , echo=T, results='hide'}
total <- x+y        # menetapkan penambahan `x` dan` y` sebagai variabel `total`
average <-(x+x+y)/3 # menetapkan rata-rata beberapa variabel
```


### Probabilitas

R dapat digunakan sebagai kalkulator probabilitas. Anda mungkin berharap mengetahui ini ketika melakukan kelas Intro To Probability anda.

```{r, echo=T, results='hide'}
dbinom (x = 3, size = 10, prob = 0.5)	     # Fungsi Kepadatan (DF) P (X = 3) 
dbinom (3, 10, 0.5) 				               # hasil yang sama seperti di atas
pbinom (q = 3, size = 10, prob = 0.5) 		 # Fungsi Distribusi Kumulatif
qbinom (p = 0.1718, size = 10, prob = 0.5) # kuantil untuk X ~ B (n = 10, p = 0.5)
rbinom (n = 10, size = 10, prob = 0.5)	 	 # menghasilkan variabel acak
#? distributions 					                 # Untuk informasi lebih lanjut
```

R memiliki banyak distribusi bawaan. Nama mereka mungkin berubah, tetapi awalannya tetap tidak berubah, contoh:

*	`d` awalan untuk fungsi kerapatan (density function).
*	`p` awalan untuk fungsi distribusi kumulatif (Cummulative distribution function/CDF).
*	`q` awalan untuk fungsi kuantil (mis., CDF terbalik atau inverse CDF).
*	`r` awalan untuk menghasilkan sampel acak.

Gunakanlah ide-ide dibawah ini dengan menggunakan beberapa distribusi CDF :

*	`pbinom()` untuk Binomial CDF.
*	`ppois()` untuk Poisson CDF.
*	`pnorm()` untuk Gaussian CDF.
*	`pexp()` untuk Eksponensial CDF.

## Bantuan

Salah satu bagian terpenting dari bekerja dengan bahasa adalah mengetahui di mana mencari bantuan. Selain berbagai sumber daya bantuan dalam ekosistem R, selain itu R juga memiliki beberapa fasilitas in-line. Dapatkanlah bantuan untuk fungsi tertentu.

```{r, eval=FALSE}
?dbinom
help(dbinom)
```

Jika Anda tidak tahu nama fungsi yang anda cari, carilah file bantuan lokal untuk string tertentu:

```{r, eval=FALSE}
??binom
help.search ('dbinom')
```

Atau memuat menu agar Anda dapat menavigasi bantuan lokal berbasis web:

```{r, eval=FALSE}
help.start()
?help
```

## Statistik Dasar

Mari kita terapkan beberapa output ke objek bernama "x", lalu kita akan melihat beberapa statistik dasar:

```{r , echo=T, results='hide'}
x = rbinom (n = 10, size = 10, prob = 0.5) 	    # ini berfungsi tetapi merupakan cara yang buruk.
x <- rbinom (n = 10, size = 10, prob = 0.5)	    # cara terbaik
```

**Catatan:** Jika Anda terbiasa dengan bahasa pemrograman lain, Anda mungkin lebih menggunakan  penugasan `=` daripada penugasan `<-`.

```{r , echo=T, results='hide'}
x 		                                          # cetak konten suatu objek cukup ketik namanya
print (x)                                       # mencetak konten suatu objek secara implisit
(x <- rbinom (n = 10, size = 10, prob = 0.5))   # cara alternatif untuk menetapkan dan mencetak
mean (x) 	                                      # Menghitung rata-rata
var (x) 	                                      # Menghitung variansi
sd (x) 		                                      # Simpangan baku
hist (x) 		                                    # Plot histogram
```

R menyimpan setiap objek yang Anda buat dalam RAM. Semua koleksi dari semua objek tersebut adalah ruang kerja yang dapat Anda periksa dengan:

```{r , echo=T, results='hide'}
ls () 			                                    # Koleksi semua objek tersebut
ls (pattern = 'x') 	                            # menggunakan ls dengan pola teks
rm (x) 			                                    # Menghapus variabel
ls () 		                                  	  # Memverifikasi
```

Anda mungkin berpikir bahwa jika suatu objek dihapus maka memorinya akan dilepaskan. Ini hampir benar, tergantung pada mekanisme negosiasi antara R dan sistem operasi.

## Piping

Karena R berasal dari lingkungan seperti Unix dan Linux, ia mewarisi banyak ragamnya. `Piping` adalah ide yang diambil dari shell Linux yang memungkinkan untuk menggunakan output dari satu ekspresi sebagai input ke yang lain. Dengan demikian, `Piping` membuat kode lebih mudah dibaca dan ditulis.

```{r , echo=T, results='hide', message=F}
# Prasyarat:
library(magrittr)                                  # Memuat fungsi piping
# help(package = "magrittr")                       # Memuat informasi `magrittr`
x <- rbinom(n=1000, size=10, prob=0.5)           	 # Menghasilkan beberapa sampel data
# Contoh:
x %>% var()                                        # Bukan `var(x)`
x %>% hist()                                     	 # Sebagai ganti `hist(x)`
x %>% mean() %>% round(2) %>% add(10)              # Sebagai ganti beberapa fungsi
```

Contoh berikutnya menunjukkan manfaat dari piping. Dua potongan kode selanjutnya melakukan hal yang sama. Coba uraikan dalam pikiran Anda:

```{r , echo=T, results='hide'}
# Gaya fungsional Onion style
car_data <- 
transform(aggregate(. ~ cyl, 
                    data = subset(mtcars, hp > 100), 
                    FUN = function(x) round(mean(x, 2))), 
                    kpl = mpg*0.4251)
```

```{r , echo=T, results='hide'}
# Piping (magrittr) style
car_data <- mtcars %>%
  subset(hp > 100) %>%
  aggregate(. ~ cyl, data = ., FUN = . %>% mean %>% round(2)) %>%
  transform(kpl = mpg %>% multiply_by(0.4251)) %>%
  print()
```

**Tip:** RStudio memiliki jalan pintas melalui keyboard untuk operator `%>%`. Coba `Ctrl+Shift+m`.

## Membuat Vektor

Elemen paling dasar dalam R adalah vektor. Kita sekarang akan melihat cara membuat vector  dan mengakses elemen-elemen (yaitu, subset). Berikut adalah tiga cara untuk membuat vektor yang sama:

```{r , echo=T, results='hide'}
c(10,11,12,13,14,15,16,17,18,19,20,21) 		  # Membuat vektor secara manual
10:21                                  			# Menggunakan operator `:`
seq(from=10, to=21, by=1)              		  # fungsi `seq()` dengan "by"
seq(from=10, to=21, len=12)          		    # fungsi `seq()` dengan "len"
x <- 10:21                             			# Mari kita tetapkan ke objek bernama "x"
x+2                                    			# Operasi biasanya bekerja berdasarkan elemen
x*2                                    			# Tambahkan 2 untuk setiap elemen `x`
x^2                                    			# Pangkat 2 untuk setiap elemen `x` 
sqrt(x)                                			# Akar kuadrat untuk setiap elemen ‘x’
log(x)                                			# Logaritma untuk setiap elemen 'x’ 
x <- c(0.5, 0.6)                       			# Numerik
x <- c(TRUE, FALSE)                    			# Logis
x <- c(T, F)                        				# Logis
x <- c("a", "b", "c")                  			# Karakter
x <- 9:29                              			# Integer
x <- c(1+0i, 2+4i)                     			# Kompleks
x <- vector("numeric", length = 10)    		  # fungsi `vektor ()` untuk menginisialisasi vektor.
y <- c(1.7, "a")                      			# Karakter
y <- c(TRUE, 2)                     			  # Numerik
y <- c("a", TRUE)                      			# Numerik
typeof(y)                              			# Untuk memeriksa jenis `y`
class(y)                               			# Untuk memeriksa jenis `y`
```

**Catatan:** Menurut [dokumentasi R](https://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html#Objects) untuk `typeof()` dan `class()`, pernyataan tentang "perbedaan utama/main difference" adalah tidak benar. Kelas adalah atribut dari objek yang dapat ditetapkan terlepas dari mode penyimpanan internalnya, sedangkan `typeof()` menentukan tipe (R internal) atau mode penyimpanan dari objek apa pun. Satu menggambarkan karakteristik logis sedangkan yang lain adalah karakteristik fisik dari suatu objek.

```{r , echo=T, results='hide'}
x <- 0:10                              	   # Mari tetapkan ke objek bernama `x`
class(x)                               	   # Periksa kelas `x`
as.numeric(x)                       	     # Menetapkan `x` sebagai numerik
as.logical(x)                          	   # Menetapkan `x` sebagai logis
as.character(x)                        	   # Menetapkan `x` sebagai karakter
as.numeric(c(FALSE,TRUE,TRUE,FALSE))       # Menetapkan vektor logis sebagai angka 
```

Terkadang, R tidak dapat menemukan cara untuk memaksa suatu objek dan ini dapat menghasilkan NA.

```{r , echo=T, results='hide'}
x <- c("a", "b", "c","1")       	         # menetapkan nilai `x`
as.numeric(x)                          	   # menetapkan `x` sebagai numerik
as.logical(x)                        	     # menetapkan `x` sebagai logis
as.complex(x)                        	     # menetapkan `x` sebagai karakter
```

**Catatan:** Saat paksaan tidak masuk akal terjadi, Anda biasanya akan mendapat peringatan dari R.

Kita sudah melihat bahwa elemen dasar dari objek R adalah vektor. Vektor dapat ditetapkan dengan berbagai jenis berikut:

*	**character:** di mana setiap elemen adalah string, mis., urutan simbol alfanumerik.
*	**numeric:** di mana setiap elemen adalah [bilangan real](https://en.wikipedia.org/wiki/Real_number) dalam format floating point [presisi ganda](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).
*	**integer:** di mana setiap elemen adalah [integer](https://en.wikipedia.org/wiki/Integer).
*	**logis:** di mana setiap elemen adalah TRUE, FALSE, atau NA3
*	**complex:** di mana setiap elemen adalah bilangan kompleks.

## Matriks

Matriks adalah vektor dengan atribut dimensi. Atribut dimensi itu sendiri merupakan vektor integer dengan panjang 2 (jumlah baris, jumlah kolom)

```{r , echo=T, results='hide'}
m <- matrix(nrow = 2, ncol = 3)          # Membuat matriks `NA` sebanyak 2x3
m                                        # Mencetak hasilnya
dim(m)                                   # Memeriksa dimensi
attributes(m)                            # Memeriksa dimensi
```

Matriks dibuat berdasarkan kolom, sehingga entri dapat dianggap dimulai dari sudut "kiri atas" dan mengalir di kolom.

```{r , echo=T, results='hide'}
m <- matrix (1: 6, nrow = 2, ncol = 3)   # Membuat sebuah matriks dengan 2x3
```

Matriks juga dapat dibuat langsung dari vektor dengan menambahkan atribut dimensi.

```{r , echo=T, results='hide'}
m <- 1:10                                # Membuat vektor `m`
dim(m) <- c(2, 5)                        # Menetapkan vektor `m` sebagai matriks sebesar 2x5
m                                        # Mencetak hasilnya
```

Matriks dapat dibuat dengan pengikatan kolom atau pengikatan baris dengan fungsi `cbind()` dan `rbind()`.

```{r , echo=T, results='hide'}
x <- 1:3                                 # Membuat vektor `x`
y <- 10:12                               # Membuat vektor `y`
cbind(x, y)                              # Menggabungkan vektor `x` dan` y` dengan kolom
rbind(x, y)                              # Menggabungkan vektor `x` dan` y` dengan baris
```

## Daftar

Daftar (Lists) adalah jenis vektor khusus yang dapat berisi elemen dari kelas yang berbeda. List merupakan tipe data yang sangat penting dalam R dan Anda harus mengenalnya dengan baik. List, dalam kombinasi dengan berbagai fungsi "apply" yang akan dibahas nanti, membuat kombinasi yang kuat. List dapat dibuat secara eksplisit menggunakan fungsi `list()`, yang mengambil sejumlah argumen arbitrer.

Secara umum Anda dapat menggunakan dua operasi pengindeksan yang berbeda pada List:

*	Kurung tunggal untuk mengembalikan daftar elemen yang dipilih `([])`
*	Kurung ganda untuk mengembalikan elemen tunggal `([[]])`

```{r , echo=T, results='hide'}
x <- list(1:5,c("a","b","c"),TRUE,7,5)  # Membuat daftar (list) vektor `x`
x[1]                                    # Kurung tunggal
x[[1]]                                  # Kurung ganda
typeof(x[2])                            # Memeriksa jenis objek menggunakan []
typeof(x[[2]])                          # Memeriksa jenis objek menggunakan [[]]
x[c(1,2)]                               # list vektor pertama dan kedua
```

Kita juga dapat membuat daftar (list) dengan mengganti objek kosong yang ada seperti yang Anda lihat dalam kode berikut:

```{r , echo=T, results='hide'}
x <- vector("list", length = 3)         # Membuat daftar (list) kosong (sesuai kebutuhan)
name <- c("a","b","c","d")              # Membuat objek sebagai variabel `name`
age  <- c(18, 19, 20, 21)               # Membuat objek sebagai variabel `age`
gender<- c(1, 0, 0, 1)                  # Membuat objek sebagai variabel `gender`
x[[1]] <- name                          # Tambah / ganti objek ke daftar `x`
x[[2]] <- age                           # Tambah / ganti objek ke daftar `x`
x[[3]] <- gender                        # Tambah / ganti objek ke daftar `x`
x                                       # Cetak hasil akhir
```

## Faktor

Faktor-faktor digunakan untuk mewakili data kategorikal dan dapat menjadi tidak teratur atau teratur. Orang dapat menganggap faktor sebagai vektor integer di mana setiap integer memiliki label. Faktor-faktor menjadi penting dalam pemodelan statistik dan diperlakukan secara khusus oleh fungsi pemodelan seperti `lm()` dan `glm()`.

Menggunakan faktor dengan label lebih baik daripada menggunakan bilangan bulat karena faktor menggambarkan diri sendiri. Memiliki variabel yang memiliki nilai "Laki-laki" dan "Perempuan" lebih baik daripada variabel yang memiliki nilai 1 dan 2. Objek-objek dapat dibuat dengan fungsi `faktor()`.

```{r , echo=T, results='hide'}
x <- factor(c("yes","no","yes","no"))  # Membuat objek faktor
x                                      # Cetak hasilnya
table(x)                               # Tabel dari `x`
unclass(x)                             # Melihat representasi faktor yang mendasarinya
attr(x,"levels")                       # Melihat representasi faktor yang mendasarinya
```

## Data Frame

Kerangka data (data frame) adalah tabel atau struktur mirip array dua dimensi di mana setiap kolom berisi nilai satu variabel dan setiap baris berisi satu set nilai dari setiap kolom.

Berikut ini adalah karakteristik data frame.

*	Nama kolom tidak boleh kosong;
*	Nama baris harus unik;
*	Data yang disimpan dalam data frame bisa dari numerik, faktor atau tipe karakter;
*	Setiap kolom harus berisi jumlah item data yang sama.

```{r , echo=T, results='hide'}
# Buat data frame pertama.
df1 <- data.frame(id = c (1:5), 
                name = c("Julian","Vanessa","Jeffry","Angel","Nikki"),
              salary = c(623.3,515.2,611.0,729.0,843.25), 
          start_date = as.Date(c("2022-01-01", "2022-09-23", "2022-11-15",                                               "2022-05-11", "2022-03-27")),
                dept = c("DS","DS","BA","DA","DS"), stringsAsFactors = F)
df1
```

```{r , echo=T, results='hide'}
# Buat data frame kedua.
df2 <-data.frame(id = c (6:10), 
               name = c("Ardifo","Irene","Kefas","Sherly","Bakti"),
             salary = c(578.0,722.5,632.8,632.8,NA), 
         start_date = as.Date(c("2022-05-21","2022-07-30","2022-06-17",
                                "2022-07-30","2018-09-03")),
               dept = c("Actuaries","Actuaries","CA","DE","Lecturer"),stringsAsFactors = F)
df2
```

```{r , echo=T, results='hide'}
df3 <- rbind(df1,df2)                  # Gabungkan dua frame data
print(df3)                             # Cetak hasilnya `df3`
head(df3)                              # Cetak enam baris pertama
head(df3,6)                            # Cetak enam baris pertama
#View(df3)                             # Menggunakan RStudio seperti penampil Excel
class(df3)                             # objeknya bertipe data.frame
str(df3)                               # Dapatkan struktur data frame
dim(df3)                               # Periksa dimensi data
```

Data frame biasanya dibuat dengan membaca dalam dataset menggunakan `read.table()` atau `read.csv ()`. Namun, data frame juga dapat dibuat secara eksplisit dengan fungsi `data.frame()` atau mereka dapat dipaksakan dari jenis objek lain seperti list.

## Menghasilkan Data Frame

Sebagai seorang Data Scientist, ketika mencoba mennyimulasikan proses analisis data, pemodelan, dan bahkan prediksi, Anda harus mampu secara intuitif membangun dataframe untuk memperkirakan kumpulan data sampel. Terutama, ketika Anda tidak memiliki kumpulan data sampel sama sekali. Oleh karena itu, pada bagian ini, kita akan belajar sedikit mengenai cara menghasilkan dataframe. Harap pertimbangkan baik-baik contoh berikut:

```{r , echo=T, results='show'}
# Misalkan Anda ingin membangun kumpulan data karyawan di sebuah perusahaan

No<-(1:52)                                       # Menghasilkan bilangan 1-52
Name<-c(LETTERS,letters)                         # 26 LETTERS dan 26 letters
Gender<-sample(rep(c("Male","Female"),times=26)) # 26 Laki-laki dan 26 perempuan

# Menghasilkan tanggal lahir
year_in_3<-seq(as.Date("2000/01/01"), by="year", length.out=4)
Birthday <- rep(year_in_3, times=13)

# Menghasilkan kategori universitas
univ1<-rep("National",times=26)                  # 26 universitas negeri
univ2<-rep("Private",times=16)                   # 16 universitas swasta 
univ3<-rep("Overseas",times=10)                  # 10 universitas luar negeri
Universities<-sample(c(univ1,univ2,univ3))       # Menggabungkan data (vetor)

gpa<-runif(52,min=3.00,max=4.00)                 # Menghasilkan 52 bilangan acak (min=3, dan max=4) 
GPA<-round(gpa,digits=2)                         # Mengatur digit bilangan acak Anda
Salary<-sample(600:1200,52,replace=T)            # Menghasilakn sampel antara 600-1200 (memungkinkan nilai duplikat)
Employees<-data.frame(No,
                      Name,
                      Birthday,
                      Gender,
                      Universities,
                      GPA,
                      Salary)
Employees
```

## Ekstraksi

R menyediakan banyak cara untuk mengelompokkan dan mengekstrak elemen dari vektor dan objek lainnya. Dasar-dasarnya cukup sederhana, tetapi dengan tidak memperhatikan "kepribadian" dari setiap mekanisme ekstraksi dapat menyebabkan Anda sakit kepala. Sebagai permulaan, ekstraksi dilakukan dengan operator `[]`. Operator dapat mengambil vektor dari banyak jenis.

```{r , echo=T, results='hide'}
#View(Employees)                                 # Lihat dataset `Employees` (environment R)
typeof(Employees)                                # Memeriksa jenis data
class(Employees)                                 # Memeriksa kelas data
Employees[1,5]                                   # Mengekstrak elemen di baris ke-1 dan ke-5 kolom
Employees$Name                                   # Mengekstrak kolom terntentu (`Name`)
Employees[,c('Name','Gender')]                   # Mengekstrak kolom tertentu (`Name, Gender`)
Employees[1:5,]                                  # Mengekstrak lima baris pertama dari Employees
Employees[,1:5]                                  # Mengekstrak lima kolom pertama dari Employees

subset(Employees, select=GPA)                    # Mengekstrak/subset kolom tertentu
subset(Employees, select=6)                      # Mengekstrak/subset kolom tertentu
subset(Employees, select= c(6,7))                # Mengekstrak/subset kolom pertama dan kedua
subset(Employees, select= c(2:5))                # Mengekstrak/subset kolom tertentu
```

Menambah variabel baru ke dalam dataframe dapat dilakukan dengan menetapkan vektor baru. Kekuatan objek dataframe adalah menerima hampir semua jenis vektor, mis. integer, numerik, logika, faktor, dan karakter.

```{r , echo=T, results='hide'}
Employees$Tax <- Employees$Salary*0.03                    # Tambahkan variabel baru 'Tax' ke dataframe Employess
Employees$Take_Home_Pay <- Employees$Salary-Employees$Tax # Tambahkan variabel baru 'Take_Home_Pay' ke dataframe Employess
Employees$Category_Salary1 <- Employees$Salary > 950      # Tambahkan variabel baru 'Category_Salary1' ke dataframe Employess
Employees$Category_Salary2<-ifelse(Employees$Salary > 950, 
                                    "High", 
                                    "Low")                # Tambahkan variabel baru 'Category_Salary2' ke dataframe Employess
Employees$Category_Salary2<-factor(Employees$GPA >3.5 & 
                                   Employees$Salary>950,
                                   labels = c("level1",
                                              "level2"))
min(Employees$Salary)                                     # Temukan nilai minimum dari `Salary`
max(Employees$Salary)                                     # Temukan nilai mksimum dari `Salary`
mean(Employees$Salary)                                    # Temukan nilai rata-rata dari `Salary`
var(Employees$Salary)                                     # Temukan nilai variansi dari `Salary`
sd(Employees$Salary)                                      # Temukan nilai standar deviasi dari `Salary`
summary(Employees)                                        # Ringkasan statistik sederhana dari `Employees`
```

**Penting:** Berhati-hatilah saat Anda mencoba mengekstrak kumpulan data yang berisi nilai yang hilang, jangan lupa mengabaikannya, atau menghapusnya terlebih dahulu. Mari kita lihat contoh berikut:

```{r , echo=T, results='hide'}
#View(mtcars)                          # Lihat dataset `mtcars` (environment R)
#?mtcars                               # Informasi detail tentang mtcars
min(mtcars$mpg )                       # Temukan minimum gallon Miles/(US) 
max(mtcars$mpg , na.rm = TRUE)         # Temukan maksimum gallon Miles/(US)
mean(mtcars$mpg , na.rm = TRUE)        # Temukan rata-rata gallon Miles/(US)
var(mtcars$mpg , na.rm = TRUE)         # Temukan varians gallon Miles/(US)
sd(mtcars$mpg , na.rm = TRUE)          # Temukan standar deviasi gallon Miles/(US)
```

## Mengubah Nama Data Frame

Objek R dapat memiliki nama, yang sangat berguna untuk menulis kode yang dapat dibaca dan menggambarkan objek sendiri. Di sini, Anda akan belajar cara mengganti nama kolom dari dataframe pada R menggunakan fungsi `names()`.

```{r , echo=T, results='show'}
rename_1<-Employees                             # Mengubah nama variabel
names(rename_1)<-c("no", 
                    "nama",
                    "tgl.lahir",
                    "jenis.kelamin",
                    "universitas", 
                    "ipk",
                    "gaji")                     # Mengubah nama variabel menjadi Indonesia
rename_1                                        # Cetak hasilnya
```

Ini juga dapat diselesaikan menggunakan fungsi `rename()` [package dplyr]

```{r , echo=T, results='show'}
library(tidyverse)
Employees %>% 
  rename("no"= "No",
         "nama" = "Name",         
         "tanggal.lahir" = "Birthday",
         "jenis.kelamin" = "Gender"  ,   
         "universitas" = "Universities" ,
         "ipk"= "GPA",        
         "gaji"= "Salary")
```

Jika dataframe Anda dihasilkan dari fungsi `matrix()`, Anda dapat mengubah nama kolom dan barisnya.

```{r , echo=T, results='show'}
m <- matrix(1:52, nrow = 26, ncol = 2)
dimnames(m) <- list(c(LETTERS), c("AA", "BB")) 
m
```

Nama kolom dan nama baris dapat diatur secara terpisah menggunakan fungsi `colnames()` dan `rownames()`.

```{r , echo=T, results='show'}
colnames(m) <- c("Column 1", "Column 2")   # Mengubah nama kolom
rownames(m) <- c(letters)                  # Mengubah nama baris
m
```

**Catatan:** Dalam dataframe, ada fungsi terpisah untuk mengatur nama baris, fungsi `row.names()`. Juga, data frane tidak memiliki nama kolom, mereka hanya memiliki nama (seperti list). Jadi untuk mengatur nama kolom dari data frame gunakan saja fungsi `names()`. Ya, saya tahu ini membingungkan. Berikut ringkasan singkatnya:

Objek               	Tetapkan nama kolom	     Tetapkan nama baris
------------          --------------------    ---------------------
data frame	             names()	                row.names()
matrix	                 colnames()	              rownames()

## Petunjuk Penting

Beberapa petunjuk bermanfaat untuk Rstudio (IDE) meliputi:
   
Kata Kunci	                         Perintah	                             Detail
----------------------     -------------------------------------    -----------------------
Ctrl + Return (Enter)	      untuk menjalankan baris dari editor	           ~
Ctrl + Shift + #	          untuk fokus pada tab bantuan	                 kontradiktif
Alt + Shift + k	            untuk jalur pintas keyboard RStudio	           ~
Ctrl + r	                  untuk menelusuri sejarah perintah	             ~
Alt + Shift + j	            untuk menavigasi antar bagian kode	           ~
Ctrl + 1	                  untuk melompat ke editor	                     tab untuk penyelesaian otomatis
Ctrl + 2	                  untuk melompat ke konsol	                     tab untuk penyelesaian otomatis
Ctrl + 8	                  untuk melompat ke environment list	           tab untuk pelengkapan otomatis
Alt + l	                    Collapse chunk	                               Code Folding
Alt + Shift + l	            Unfold chunk	                                 Code Folding
Alt + o	                    Collapse all	                                 Code Folding
Alt + Shift + o	            Unfold all	                                   Code Folding
Alt + “-”	                  untuk operator penugasan <-	                   ~
Alt + Shift + c	            kode komentar/tanda komentar dalam file .R	   kontradiktif

Saat ini, saya menyarankan Anda untuk menggunakan RStudio di komputer (PC) Anda, tetapi di sini saya sarankan beberapa **IDE lain:**

* Rstudio Cloud: [https://rstudio.cloud/](https://rstudio.cloud/)
* Kaggle: [https://www.kaggle.com/](https://www.kaggle.com/)
* R Notebook: [https://rnotebook.io/](https://rnotebook.io/)

<!--chapter:end:02-Dasar-dasar-R.Rmd-->

# Pemrograman R {#Pemrograman-R}
***

## Apa itu Pemrograman?

Ada banyak sekali definisi tentang apa itu pemrograman, di sini saya mengumpulkan empat frasa kunci diantaranya:

* Pemrograman adalah proses pengambilan algoritma dan pengkodeannya menjadi suatu notasi, sehingga bahasa pemrograman dapat dieksekusi oleh komputer. Meskipun banyak bahasa pemrograman dan berbagai jenis komputer, langkah pertama yang penting adalah kebutuhan untuk memiliki solusi. Tanpa algoritma, tidak akan ada program.
* Ilmu komputer bukanlah studi tentang pemrograman. Pemgrograman, bagaimanapun, adalah bagian penting dari apa yang dilakukan ilmuwan komputer. Pemrograman sering kali merupakan cara kita membuat representasi dari solusi kita. Oleh karena itu, representasi bahasa dan proses pembuatannyamenjadi bagian fundamental dari disiplin ilmu.
* Algoritma menggambarkan solusi untuk suatu masalah dalam hal data yang dibutuhkan untuk mewakili contoh masalah dan serangkaian langkah yang diperlukan untuk menghasilkan hasil yang diinginkan. Bahasa pemrograman harus menyediakan cara notasional untuk merepresentasikan proses dan data. Untuk tujuan ini, bahasa menyediakan konstruksi kontrol dan jenis data.
* Konstruksi kontrol memungkinkan langkah-langkah algoritmik dipresentasikan dengan cara yang nyaman namun tidak ambigu. Minimal, algoritma memerlukan konstruksi yang melakukan pemrosesan sekuensial, pemilihan untuk pengambilan keputusan, dan iterasi untuk kontrol berulang. Selama bahasa memberikan pernyataan dasar ini, itu dapat digunakan untuk representasi algoritma.

**Dalam Kata Sederhana:** Pemrograman adalah bagaimana Anda mendapatkan komputer untuk memecahkan masalah.

## Algoritma Kehidupan Nyata

Mari kita ambil situasi kehidupan nyata untuk membuat kita lebih memahami tentang algoritma ini, apa itu petunjuk langkah demi langkah yang tepat mengenai bagaimana Anda menelepon teman di telepon?

**Langkah-langkah:**

* Angkat telepon dan dengarkan nada panggil
* Tekan setiap digit nomor telepon di telepon
* Jika sibuk, tutup telepun, tunggu 5 menit, ulangi langkah kedua
* Jika tidak ada jawaban, tinggalkan pesan dan tutup
* Jika tidak ada mesin penjawab, tutup telepon dan tunggu 2 jam, kemudian ulangi langkah kedua
* Berbicara dengan teman
* Tutup telepon

**Asumsi:**

* Langkah pertama mengasumsikan bahwa Anda tinggal sendiri dan tidak ada orang lain yang dapat menjawab telepon.
* Algoritma ini mengasumsikan keberadaan telepon yang berfungsi dan layanan aktif.
* Algoritma ini mengasumsikan Anda tidak tuli atau bisu.
* Algoritma ini mengasumsikan telepon yang dijalin dengan tali normal.

## Mengapa Mempelajari Algoritma?

Secara singkat, karena waktu adalah uang. Energi adalah uang. Dan komputer dirancang untuk mengoptimalkan keduanya. Sayangnya, komputer hanya melakukan apa yang Anda perintahkan untuk komputer lakukan serta apa yang komputer pilih untuk diingat. Tugas kita adalah mencari tahu apa yang harus diberitahukan kepada komputer dan bagaimana caranya.

Salah satu cara terbaik untuk meningkatkan jangkauan Anda sebagai seorang data scientist adalah dengan menulis fungsi. Fungsi memungkinkan Anda mengotomatiskan tugas-tugas umum dengan cara yang lebih kuat dan umum daripada salin dan tempel. Fungsi sering kali digunakan untuk merangkum barisan ekspresi yang perlu dilakukan berulangkali, mungkin dalam kondisi yang berbeda. FUngsi juga sering ditulis ketika ingin membagikan kode dengan orang lain atau publik.

## Bagaimana Menulis Fungsi di R

Dalam beberapa kesempatan, kita perlu menulis fungsi kita sendiri karena kita harus menyelesaikan tugas terntentu dan tidak ada fungsi yang siap dipakai. Fungsi yang ditentukan pengguna melibatkan nama, argumen, dan isi.

### Fungsi Satu Argumen

Fungsi menerima nilai dan mengembalikan kuadrat dari nilai tersebut.

```{r, eval=FALSE}
function.name <- function(arguments) 
{
    computations on the arguments	
    some other code
}
```

#### Contoh (kuadrat) {-}

```{r}
square_function<- function(x) 
{
  x^2                                 # menghitung kuadrat dari `x`
}  
square_function(4)                    # memanggil fungsi dan melihat nilainya
```

#### Contoh (akar_kuadrat) {-}

```{r}
square_root<- function(x) 
{
  sqrt(x)                         # menghitung akar kuadrat dari `x`
}  
square_root(4)                    # memanggil fungsi dan melihat nilainya
```

#### Contoh (rata-rata) {-}

```{r}
average<- function(x) 
{
  sum(x)/length(x)                # menghitung rata-rata dari `x`
}  
x<-c(1,2,3,4,5,6)
average(x)                        # memanggil fungsi dan melihat nilainya
```

### Fungsi Multi Argumen 

Kita dapat menulis fungsi dengan lebih dari satu argumen. Pertimbangkan fungsi yang disebut "times". Ini adalah fungsi langsung yang mengalikan dua variabel.

```{r, eval=FALSE}
function.name <- function(argument1, argument2,...., argument_n) 
{
    computations on the arguments	
    some other code
}	
```

#### Contoh (perkalian) {-}

```{r}
times <- function(x,y) 
{
  x*y                                # menghitung (perkalian x dan y) 
}
times(2,4)                           # memanggil fungsi dan melihat nilainya
```

#### Contoh (volume) {-}

```{r}
volume<- function(p,l,t) 
{
  p*l*t
}
volume(5,4,3)
```

#### Contoh (frek_rata-rata) {-}

```{r}
avarage_freq <- function(x,freq) 
{
sum(x*freq)/length(x)
}
x<-c(1,2,3,4,5)
freq<-c(4,5,6,6,6)
avarage_freq(x,freq)
```

#### Contoh (frek_rata-rata_komentar) {-}

```{r}
avarage_freq_comment <- function(x,freq) 
{
 avarage <-sum(x*freq)/length(x)
 result <- paste("Avarage Frequency is", sep = " ", avarage)
 return(result)
}
avarage_freq_comment(x,freq)
```

## Contoh Kasus Sederhana

Untuk membuat fungsi di R, Anda akan membuat dan mengubah skrip R. Kita tahu bahwa cara terbaik untuk belajar berenang adalah dengan melompat ke tempat yang dalam, jadi mari kita tulis fungsi untuk menunjukkan kepada Anda betapa mudahnya hal ini di R.

### Normalisasi

Seperti yang telah saya sebutkan sebelumnya, data scientist perlu melakukan banyak tugas berulang kali. Sering kali, kita menyalin dan menempelkan potongan kode berulang kali. Contoh lain, normalisasi variabel sangat disarankan sebelum kita menjalankan algoritma machine learning. Rumus untuk menormalkan variabel adalah:

$$normalisasi = \frac{x-x_{min}}{x_{max}-x_{min}}$$

Sekarang, mari buat kerangka data seperti yang telah kita pelajari di dasar-dasar R bagian terakhir.

```{r}
set.seed(123)                                      # untuk memastikan kita mendapatkan data yang sama

df<- data.frame(                                   # membuat dataframe
  a = rnorm(10, 5, 1),                             # vektor `a` dengan bilangan acak normal
  b = rnorm(10, 5, 1),                             # vektor `b` dengan bilangan acak normal
  c = rnorm(10, 5, 1)                              # vektor `c` dengan bilangan acak normal
)
df                                                 # cetak hasil dataframe 
```

Kita sudah mengetahui cara menggunakan fungsi `min()` dan `max()` di R. Oleh karena itu kita dapat menggunakan rumus normalisasi yang kita miliki di atas untuk mendapatkan nilai normalisasi `df` sebagai berikut:

```{r}
df.norm <- data.frame(  
  a = (df$a -min(df$a))/(max(df$a)-min(df$a)), 
  b = (df$b -min(df$b))/(max(df$b)-min(df$b)),    
  c = (df$c -min(df$c))/(max(df$c)-min(df$c))    
)
df.norm                                            # cetak hasil dataframe
```

Namun, metode ini rawan akan kesalahan. Kita bisa menyalin dan lupa mengganti nama kolom setelah menempel. Oleh karena itu, praktik yang baik adalah menulis fungsi setiap kali anda perlu menempelkan kode yang sama lebih dari dua kali. Kita dapat mengatur ulang kode menjadi rumus dan memanggilnya kapan pun diperlukan. Mari pertimbangkan dengan cermat fungsi ini:

```{r}
normalize <- function(x){
  norm <- (x-min(x))/(max(x)-min(x))
  return(norm)
}
df$a<-normalize(df$a)
df$b<-normalize(df$b)
df$c<-normalize(df$c)
df
```

Meskipun contohnya sederhana, kita dapat menyimpulkan kekuatan rumus. Kode di atas lebih mudah dibaca dan terutama menghindari kesalahan saat menempelkan kode. Kita juga akan meningkatkan fungsi ini lebih efektif di bagian selanjutnya setelah Anda mempelajari cara menggunakan `for()` dan `apply()`.

### Persen

Misalkan Anda ingin menyajikan bilangan pecahan sebagai persentase, yang dibulatkan dengan baik menjadi satu digit desimal. Berikut cara mencapainya:

* Kalikan angka pecahan dengan 100.
* Bulatkan hasil ke satu  desimal: Anda dapat menggunakan fungsi `round()` untuk melakukan ini.
* Tempelkan tanda persentase setelah angka yang dibulatkan: Fungsi `paste()` siap melayani Anda untuk memenuhi tugas ini.
* Cetak hasilnya: Fungsi `print()` akan melakukan ini.

Anda dapat dengan mudah menerjemahkan langkah-langkah ini ke dalam skrip kecil untuk R. Jadi, buka file skrip baru di editor Anda dan ketikkan kode berikut:

```{r}
x <- c(0.8765, 0.4321, 0.1234, 0.05678)
percent <- round(x * 100, digits = 1)
result <- paste(percent, sep = " in ", "%")
print(result)
```

Untuk membuat skrip ini menjadi sebuah fungsi, Anda perlu melakukan beberapa hal. Lihatlah skrip sebagai pabrik kecil yang mengambil bahan angka mentah dan memolesnya hingga mengkilap yang diinginkan setiap ahli matematika.

Pertama, Anda harus membangun gedung pabrik, sebaiknya yang memiliki alamat sehingga orang tahu ke mana harus mengirim nomor mereka. Kemudian Anda harus memasang gerbang depan sehingga Anda dapat memasukkan nomor mentahnya. Selanjutnya, Anda membuat jalur produksi untuk mengubah nomor tersebut. Terakhir, Anda harus memasang gerbang belakang sehingga Anda dapat mengirimkan persentase berkilau Anda dalam dunia.

Untuk membangun pabrik Anda, ubah skrip ke kode berikut:

```{r}
addPercent <- function(x){
 percent <- round(x * 100, digits = 1)
 result <- paste(percent, sep = "", "%")
 return(result)
}
```

Jika Anda menyimpan skrip ini sebagai file .R: misalnya, addPercent.R ke komputer / PC Anda di dalam folder. Kemudian Anda sekarang dapat memanggil skrip ini di konsol dengan perintah berikut:

```{r}
source('Functions/addPercent.R')                   # pastikan working directory Anda benar
x<-normalize(df$a)                                 # menggunakan data yang dinormalisasi seperti yang kita miliki di atas
addPercent(x)                                      # menetapkan x sebagai persen dengan menggunakan fungsi 
```

## Struktur Kontrol

Pada dasarnya, struktur kontrol memungkinkan Anda untuk memasukkan beberapa "logika" ke dalam kode R Anda, daripada hanya mengeksekusi kode R yang sama setiap saat. Struktur kontrol memungkinkan Anda untuk merespons input atau fitur data dan mengeksekusi ekspresi R yang berbeda. Struktur kontrol yang umum digunakan adalah

* `if` dan `else` menguji suatu kondisi dan menindaklanjutinya
* `for` mengeksekusi loop beberapa kali
* `while` menjalankan loop saat kondisi benar
* `repeat` menjalankan loop tak terbatas (harus keluar dari itu untuk berhenti)
* `break`  mengeksekusi fraagmen loop yang rusak
* `next` melewati interasi dari sebuah loop

Sebagian besar struktur kontrol tidak digunakan dalam sesi interaktif, melainkan saat menulis fungsi atau ekspresi yang lebih panjang. Namun, konstruksi ini tidak harus digunakan dalam fungsi dan ada baiknya Anda memahaminya sebelumnya.

### `if-else`

Kombinasi `if-else` mungkin adalah struktur kontrol yang paling umum digunakan di R (bahkan untuk semua bahasa pemrograman lainnya). Struktur ini memungkinkan Anda untuk menguji suatu kondisi dan menindaklanjutinya bergantung pada benar atau salah. Anda dapat memiliki serangkaian pengujian dengan mengikuti inisial `if` dengan `else if` dan `else`. Fungsi umumnya adalah sebagai berikut:

```{r, eval=FALSE}
if (condition1) {
      do something } 
else if (condition2) {
      do something different compare to condition1} 
else (optional){
      do something different compare to others}
```

<center>
<img src="D:/Matana University/Data Scientist Handbook/Data-Science-Untuk-Pemula/if-else (chapter 3.6.1).png" style = "width:100%;">
</center>

```{r}
x <- runif(1, 0, 100)                              # mengambil satu bilangan acak dari 0 sampai 100
ifelse <- function(x){
            if (x>80){                             # kondisi 1
              print('A')}                          # hasil dari kondisi 1
            else if (x<80 & x >70){                # kondisi 2 
              print('B')}                          # hasil dari kondisi 2
            else{                                  # kondisi 3
              print('Fail')}                       # hasil dari kondisi 3
}
ifelse(x)
```

Dalam tugas Machine Learning, biasanya kita perlu membagi set data antara set rangkaian dan set pengujian. Set kereta memungkinkan algoritma untuk belajar dari data. Untuk menguji kinerja model kita, kita dapat menggunakan set pengujian untuk mengembalikan ukuran kinerja. Basis R tidak memiliki fungsi untuk membuat dua dataset. Kita bisa menulis fungsi kita sendiri untuk melakukan itu. Fungsi kita mengambil dua argumen dan disebut `split_data()`. Ide di baliknya sederhana, yaitu kita mengalikan panjang dataset (yaitu jumlah observasi) dengan 0,8. Misalnya jika kita ingin membagi dataset 80/20, dan dataset kita berisi 100 baris, maka fungsi kita akan mengalikan 0,8 * 100 = 80. Kemudian kita memiliki 80 baris yang akan dipilih untuk menjadi data pelatihan kita.

Kita akan menggunakan dataset air quality untuk menguji fungsi yang ditentukan. Dataset `airquality` memiliki 153 baris. Kita bisa melihatnya dengan kode di bawah ini:

```{r}
nrow (airquality)
```

Ini dia, kita bisa menulis fungsinya. Kita hanya perlu mengubah `airquality` ke `df` karena kita ingin mencoba fungsi kita ke dataframe apa pun, tidak hanya `airquality`:

```{r}
split_data <- function(df, train = TRUE){
  length<- nrow(df)
  total_row <- length *0.75
  split <- 1:total_row
  if (train ==TRUE){ 
    train_df <- df[split, ] 
      return(train_df)		
  } else {
    test_df <- df[-split, ] 
      return(test_df)		
  }
}
train <- split_data(airquality, train = TRUE)      # membagi untuk training data
test  <- split_data(airquality, train = FALSE)     # membagi untuk testing data
dim(train)                                         # mencetak dimensi dari training data 
```

```{r}
dim(test)                                          # mencetak dimensi dari testing data
```

Tentu saja, ada banyak package yang dapat Anda gunakan untuk membagi data training dan data testing. Tapi di sini, kita hanya membahas tentang cara membuat sebuah fungsi. Kita akan belajar membagi data training dan mencoba di bab [Manipulasi Data](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Manipulation.html#split-data).

### `for` Loops (Pengulangan)

Dalam pengalaman saya dalam melakukan analisis data, saya menemukan sangat sedikit situasi di mana `for` loop yang sangat berharga saat kita perlu mengulangi daftar elemen atau rentang angka. Tapi saya beri tahu bahwa, loop dapat digunakan untuk melakukan iterasi pada vektor, matriks, daftar, dataframe, atau objek lainnya. Satu hal yang harus Anda ketahui, R akan mengulang semua variabel dalam vektor dan melakukan komputasi yang tertulis di dalam `Expression` di bawah ini.

```{r, eval=FALSE}
For(i in vector){
  Expression	
}
```

<center>
<img src="D:/Matana University/Data Scientist Handbook/Data-Science-Untuk-Pemula/for-loop (chapter 3.6.2).png" style = "width:100%;">
</center>

**Contoh 1:** Mari mengulang semua elemen vektor dan mencetak nilai saat ini.

```{r}
fruit <- c('Apple', 'Orange', 'Papaya', 'Banana')  # membuat vektor buah
for ( i in fruit){                                 # membuat pernyataan `for`
 print(i)                                          # hasil
}
```

**Contoh 2:** Membuat fungsi non-linier dengan menggunakan polinomial x antara 1 dan 3 dan kita menyimpannya dalam daftar.

```{r}
list <- c()                                        # membuat daftar kosong
for (i in seq(1, 3, by=1)) {                       # membuat pernyataan `for`  list[[i]] <- i*i                                 # untuk mengisi daftar
}
print(list)                                        # hasil
```

**Contoh 3:** Bayangkan kita memiliki `df`, kita ingin menghitung rata-rata setiap kolom. Anda dapat melakukannya dengan salin dan tempel:

```{r}
set.seed(123)                                      # untuk memastikan kita mendapatkan data yang sama
df<- data.frame(                                   # membuat dataframe
  a = rnorm(10, 5, 1),                             # vektor `a` dengan bilangan acak normal
  b = rnorm(10, 5, 1),                             # vektor `b` dengan bilangan acak normal
  c = rnorm(10, 5, 1)                              # vektor `c` dengan bilangan acak normal
)
mean(df$a)                                         # menghitung rata-rata dari `a`
mean(df$b)                                         # menghitung rata-rata dari `b`
mean(df$c)                                         # menghitung rata-rata dari `c`
```

Tapi itu melanggar aturan praktis kita: jangan pernah menyalin dan menempel lebih dari dua kali. Sebagai gantinya, kita bisa menggunakan for loop:

```{r}
output <- vector("double", ncol(df))              # membuat daftar kosong
for (i in seq_along(df)) {                        # barisan
  output[[i]] <- mean(df[[i]])                    # tubuh
}
output                                            # hasil
```

**Contoh 4:** Sebuah matriks memiliki 2 dimensi, baris dan kolom. Oleh karena itu, untuk melakukan iterasi pada matriks, kita harus mendefinisikan dua for loop, yaitu satu untuk baris dan satu lagi untuk kolom.

```{r}
mat<- matrix(data=seq(11,20,by=1), nrow=5,ncol=2) # membuat matriks
for(r in 1:nrow(mat))                             # loop dengan r dan c untuk melakukan iterasi pada matriks
    for (c in 1:ncol(mat))  
         print(paste("Row", r, "and column",c, "have values of", mat[r,c])) 
```

```{r}
mat
```

**Tantangan Anda:** lakukan hal yang sama untuk `df` seperti yang kami gunakan di atas.

**Contoh 5:** Terkadang Anda ingin menggunakan loop untuk memodifikasi objek yang sudah ada. Misalnya, ingat tantangan kami dari fungsi [(Normalisasi)](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Rprogramming.html#write-function-in-r). Kami ingin mengubah skala/menormalkan setiap kolom dalam dataframe:

```{r}
set.seed(123)                                      # untuk memastikan kita mendapatkan data yang sama
library(tidyverse)                                 # memuat library tidyverse untuk `tibble` 
df <- tibble(                                      # dataframe menggunakan `tibble`
  a = rnorm(10, 5, 1),                             # vektor `a` dengan bilangan acak normal
  b = rnorm(10, 5, 1),                             # vektor `b` dengan bilangan acak normal
  c = rnorm(10, 5, 1)                              # vektor `c` dengan bilangan acak normal
)
rescale <- function(x) {                           # fungsi ini sama dengan `normalize`
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
for (i in seq_along(df)) {
  df[[i]] <- rescale(df[[i]])
}
df
```

### `while` Loops

Terkadang Anda bahkan tidak tahu berapa lama urutan masukan harus berjalan. Ini biasa terjadi saat melakukan simulasi. Misalnya, Anda mungkin ingin mengulang hingga mendapatkan tiga head berturut-turut. Anda tidak dapat melakukan iterasi semacam itu dengan `for` loop. Sebagai gantinya, Anda dapat menggunakan while loop . While loop lebih sederhana daripada for loop karena hanya memiliki dua komponen, kondisi dan isi.

While loop dimulai dengan menguji suatu kondisi. Jika benar, maka mereka mengeksekusi badan dari loop. Setelah badan dari loop dieksekusi, kondisinya diuji lagi, dan seterusnya, hingga kondisinya salah, setelah loop keluar. Sintaks untuk while loop adalah sebagai berikut:

```{r, eval=FALSE}
while (condition) {
     Expression
}
```

<center>
<img src="D:/Matana University/Data Scientist Handbook/Data-Science-Untuk-Pemula/while-loop (chapter 3.6.3).png" style = "width:100%;">
</center>

**Contoh 6:** Mari kita lihat contoh yang sangat sederhana untuk memahami konsep `while` loop. Anda akan membuat sebuah loop dan setelah setiap proses menambahkan 2 ke variabel yang disimpan. Anda perlu menutup loop, oleh karena itu kami secara eksplisit memberi tahu R untuk menghentikan perulangan ketika variabel mencapai 11.

```{r}
begin <- 0                                        # membuat variabel dengan 3 nilai
while (begin <= 11){                              # mebuat loop
cat('This is loop number', begin)                 # untuk melihat yang mana
begin <- begin+2                                  # tambahkan 1 ke variabel dimulai setelah setiap loop
print(begin)
}
```

**Tantangan Anda:** lakukan hal yang sama, tetapi dalam kasus ini Anda untuk membuat urutan sepuluh nilai bilangan prima.

**Contoh 7:** While loops dapat berpotensi menghasilkan pengulangan tanpa batas jika tidak ditulis dengan benar. Terkadang akan ada lebih dari satu kondisi dalam pengujian:

```{r}
z <- c(4,5,11)
while(z >= 3 && z <= 10) {
      coin <- rbinom(1, 1, 0.5)
   if(coin == 1) {                                
      z <- z + 1
      } 
   else {z <- z - 1
      } 
}
print(z)
```

Kondisi selalu dievaluasi dari kiri ke kanan. Misalnya, dalam kode di atas, jika z kurang dari 3, pengujian kedua tidak akan dievaluasi.

### `break` Loops

Pernyataan `break` yang digunakan untuk melewati/menghentikan iterasi dan mengalirkan kontrol ke luar loop (for, while, repeat). Meskipun, ini tidak umum digunakan dalam aplikasi statistik atau analisis data tetapi ada kegunaannya.

<center>
<img src="D:/Matana University/Data Scientist Handbook/Data-Science-Untuk-Pemula/break-loop (chapter 3.6.4).png" style = "width:100%;">
</center>

**Contoh 8:** Mari lakukan iterasi terhadap vektor x,yang memiliki angka berurutan dari 1 sampai 5. Di dalam loop `for` kita telah menggunakan kondisi `if` untuk `break` jika nilai saat ini sama dengan 3. Seperti yang dapat kita lihat dari output, loop berakhir ketika bertemu dengan pernyataan `break`.

```{r}
x <- 1:5
for (val in x) {
if (val == 3){
break
}
print(val)
}
```

### `next` Loops

Pernyataan `next` berguna ketika kita ingin melewatkan iterasi loop saat segera tanpa menghentikan, terlepas dari iterasi apa yang mungkin dilakukan loop.

<center>
<img src="D:/Matana University/Data Scientist Handbook/Data-Science-Untuk-Pemula/next-loop (chapter3.6.5).png" style = "width:100%;">
</center>

**Contoh 9:** Gunakan pernyataan berikutnya di dalam kondisi untuk memeriksa apakah nilainya sama dengan 3. Jika nilainya sama dengan 3, evaluasi saat ini berhenti (nilai tidak dicetak) tetapi pengulangan berlanjut dengan iterasi berikutnya.

```{r}
x <- 1:5
for (val in x) {
if (val == 3){
next
}
print(val)
}
```

### `repeat` Loops

`repeat` loop digunakan untuk mengulang satu blok kode beberapa kali. Tidak ada pemeriksaan kondisi di loop untuk keluar. Kita sendiri harus menempatkan kondisi secara eksplisit di dalam tubuh loop.

<center>
<img src="D:/Matana University/Data Scientist Handbook/Data-Science-Untuk-Pemula/repeat-loop (chapter 3.6.6).png" style = "width:100%;">
</center>

**Contoh 10:** Mari gunakan kondisi untuk memeriksa dan keluar dari loop saat $x$ mengambil nilai 6. Oleh karena itu, kita akan melihat dalam output kita bahwa hanya nilai dari 1 hingga 5 yang dicetak.

```{r}
x <- 1
repeat {
    print(x)
    x = x+1
  if (x == 6){
  break
  }
}
```

## Fungsi Loop

Menulis loop `for, while, dll` berguna saat memprogram tetapi tidak terlalu sesuai saat bekerja secara interaktif pada baris perintah. Ekspresi multi-garis dengan tanda kurung kurawal tidak begitu nyaman untuk disortir saat mengerjakan. R memiliki beberapa fungsi yang mengimplementasikan perulangan dalam bentuk yang ringkas untuk mempermudah pekerjaan anda sebagai data scientist.

* `tapply()` Fungsi berguna di atas subset vektor
* `lapply()` Ulangi daftar dan evaluasi fungsi pada setiap elemen
* `sapply()` Sama seperti lapply tetapi coba menyederhanakan hasilnya
* `apply()` Fungsi yang berguna di atas margin array
* `mapply()` Versi multivariasi dari lapply
**Catatan:** Perulangan (looping) sebenarnya dilakukan secara internal dalam kode C untuk alasan efisiensi.

### `tapply()`
`tapply()` digunakan untuk menerapkan fungsi di atas subset vektor. Ini dapat dianggap sebagai kombinasi `split()` dan `sapply()` untuk vektor saja. Saya telah diberi tahu bahwa "t" di `tapply()` mengacu pada "tabel", tapi itu belum dikonfirmasi.

```{r}
str (tapply)
```

Argumen untuk `tapply()` adalah sebagai berikut: 
* `X` adalah vektor 
* `INDEX` adalah faktor atau daftar faktor (atau mereka dipaksa menjadi faktor) 
* `FUN` adalah fungsi yang akan diterapkan 
* `...` berisi argumen lain untuk dilewatkan `FUN` 
* `simplify` haruskah kita menyederhanakan hasilnya?

**Contoh 11:** Untuk memahami cara kerjanya, mari gunakan dataset `iris`. Dataset ini sangat terkenal di dunia pembelajaran mesin. Tujuan dari dataset ini adalah untuk memprediksi kelas dari masing-masing dari tiga spesies bunga: Sepal, Versicolor, Virginica. Dataset mengumpulkan informasi untuk setiap spesies tentang panjang dan lebarnya.

```{r}
data(iris)                                        # memuat dataset `iris`
tapply(iris$Sepal.Width, iris$Species, mean)      # rata-rata lebar tiap spesies
```

Kita juga dapat mengambil rata-rata grup tanpa menyederhanakan hasilnya, yang akan memberi kita daftar (list). Untuk fungsi yang mengembalikan nilai tunggal, biasanya ini bukan yang kita inginkan, tapi bisa dilakukan.

```{r}
tapply (iris$Sepal.Width, iris$Species, mean, simplify = F)
```

### `lapply()`

Fungsi ini berguna untuk melakukan operasi pada objek daftar dan mengembalikan objek daftar dengan panjang yang sama dari set aslinya. Ini akan mengembalikan daftar dengan panjang yang sama sebagai objek daftar masukan, yang masing-masing elemennya merupakan hasil dari penerapan `FUN` ke elemen daftar (list) yang sesuai.

**Contoh 12:** Gunakan fungsi `mean()` untuk semua elemen daftar. Jika daftar asli memiliki nama, nama-nama tersebut akan dipertahankan di dalam output.

```{r}
lapply(df, mean)                                  # ambil mean dari setiap kolom `df`
```

**Contoh 13:** Ubah nilai string matriks menjadi huruf kecil dengan fungsi tolower. Kita membuat matriks dengan nama film terkenal. Nama dalam format huruf besar.

```{r}
movies <- c("FOUNDATION",
            "AVENGERS",
            "HAMILTON",
            "CHINATOWN")                          # membuat vektor film terkenal
movies_lower <-lapply(movies, tolower)            # huruf kecil dengan fungsi `tolower`
str(movies_lower)                                 # mari lihat hasilnya
```

```{r}
movies_lower <-unlist(lapply(movies,tolower))     # `unlist()` untuk mengonversi daftar menjadi vektor
str(movies_lower)
```

### `sapply()`

Fungsi `sapply()` berperilaku mirip dengan `lapply()`; satu-satunya perbedaan nyata adalah pada nilai pengembaliannya. `sapply()` akan mencoba menyederhanakan hasil dari `lapply()` jika memungkinkan. Pada dasarnya, `sapply()` memanggil `lapply()` pada inputnya dan kemudian menerapkan algoritma berikut:

* Jika hasilnya adalah daftar (list) di mana setiap elemen memiliki panjang 1, maka vektor dikembalikan
* Jika hasilnya adalah daftar (list) di mana setiap elemen adalah vektor dengan panjang yang sama (>1) , matriks dikembalikan.
* Jika tidak bisa memahaminya, daftar (list) dikembalikan 

```{r}
sapply(df, mean)                                  # ambil rata-rata (mean) dari setiap kolom `df`
```

### `apply()`

Fungsi `apply()` mengambil dataframe atau matriks sebagai masukan dan memberikan keluaran dalam vektor, daftar atau larik (array). Ini juga terutama digunakan untuk menghindari penggunaan eksplisit dari konstruksi perulangan. Selain itu, fungsi ini adalah yang paling dasar dari semua fungsi loop yang dapat digunakan melalui matriks.

Fungsi ini membutuhkan 3 argumen:

```{r}
str (apply)
```

Argumen untuk `apply()` adalah

* `X` adalah sebuah array (bisa berupa data frame, list, vector, dll)
* `MARGIN` adalah vektor integer yang menunjukkan margin mana yang harus "dipertahankan".
* `FUN` adalah fungsi yang akan diterapkan
* `...` adalah untuk argumen lain yang akan diteruskan ke `FUN`

**Contoh 11:** Mari buat matriks 20 kali 10 dari bilangan acak Normal. Kemudian hitung rata-rata setiap baris. Anda juga dapat menghitung jumlah setiap kolom.

```{r}
x <- matrix(rnorm(200), 20, 10)                   # membuat matriks dari bilangan acak normal 
apply(x, 1, mean)                                 # ambil rata-rata setiap baris
```

```{r}
apply(x, 2, sum)                                  # ambil rata-rata dari setiap kolom
```

Anda mungkin telah memperhatikan bahwa argumen kedua `MARGIN` adalah 1 atau 2, bergantung pada apakah kita menginginkan statistik baris atau statistik kolom. Sebenarnya, ada beberapa kasus khusus dari jumlah `kolom/baris` dan rata-rata matriks `kolom/baris`, kita memiliki beberapa cara pintas yang berguna.

* rowSums  = apply(x, 1, sum)
* rowMeans = apply(x, 1, mean)
* colSums  = apply(x, 2, sum)
* colMeans = apply(x, 2, mean)

**Contoh 12:** Melihat kembali masalah [normalisasi](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Rprogramming.html#normalize), kita bisa menyelesaikannya dengan cara yang lebih sederhana menggunakan `apply()`:

```{r}
normalize <- function(x){
  norm <- (x-min(x))/(max(x)-min(x))
  return(norm)
}
apply(df, 2, normalize)   
```

### `mapply()`

Fungsi `mapply()` adalah penerapan multivariasi jenis yang menerapkan fungsi secara paralel pada sekumpulan argumen. Ingat bahwa `lapply()` dan teman-teman hanya melakukan iterasi pada satu objek R. Bagaimana jika Anda ingin mengulang beberapa objek R secara paralel? Inilah gunanya `mapply()`.

```{r}
str(mapply)
```

Argumen untuk `mapply()` adalah:

* `FUN` adalah fungsi untuk diterapkan
* `...` berisi objek R untuk diterapkan
* `MoreArgs` adalah daftar argumen lain untuk `FUN`
* `SIMPLIFY` menunjukkan apakah hasil harus disederhanakan

Fungsi `mapply()` memiliki urutan argumen yang berbeda dari `lapply()` karena fungsi yang akan diterapkan lebih dulu daripada objek yang akan diiterasi. Objek R di mana kita menerapkan fungsi yang diberikan dalam argumen `...` karena kita dapat menerapkan sejumlah objek R.

**Contoh 13:** Buat daftar yang berulang `list(rep(1,4), rep(2,3), rep(3,2), rep(4,1))`

```{r}
mapply(rep, 1:4, 4:1)
```

**Contoh 14:** Membuat simulasi variabel Normal acak.

```{r}
noise <- function(n, mean, sd) {
            rnorm(n, mean, sd)
}
noise(5, 1, 2)                                    # Simulasikan 5 bilangan acak
```

```{r}
apply(x, 2, sum)                                  # Ambil mean dari setiap kolom
```

```{r}
noise(1:5, 1:5, 2)                                # Ini hanya mensimulasikan 1 set angka, bukan 5
```

```{r}
# dapatkan 5 set bilangan acak,
# masing-masing dengan panjang dan rata-rata yang berbeda
mapply(noise, 1:5, 1:5, 2)       
```

<!--chapter:end:03-Pemrograman-R.Rmd-->

# Interface Data {#Interface-Data}
***

Dengan R, kita dapat membaca data dari file yang tersimpan di luar Environment R. Kita juga dapat menulis data menjadi bentuk file yang akan disimpan dan diakses oleh sistem operasi. R dapat membaca dan menulis ke beberapa format file seperti `csv, excel, txt, rds, xml, json, dll`.

<center>
<img src="D:/Matana University/Data Scientist Handbook/Data-Science-Untuk-Pemula/interface (chapter 4).png" style = "width:100%;">
</center>

## Direktori Kerja (Working Directory)

Sebelum kita mulai bekerja menggunakan data (data interface), pertama-tama pastikan working directory Anda berada di koneksi yang tepat. Anda dapat memeriksanya menggunakan fungsi `getwd()`. Anda juga dapat mengeset sebuah working directory baru menggunakan fungsi `setwd()`.

```{r, echo=T}
print(getwd())                                    # memperoleh dan mencetak working directory
getwd()                                           # memperoleh dan mencetak working directory 
#setwd("C:/Users/Bakti/Desktop/")                 # mengeset working directory Anda 
#setwd("C:\\Users\\Bakti\\Desktop\\")             # atau dengan cara ini
```


## Membaca/Menulis CSV

Ini adalah sebuah contoh sederhana dari fungsi `read.csv` untuk membaca sebuah file CSV yang tersedia di working directory Anda saat ini.

```{r, echo=T}
# csv <- read.csv(file.choose())                  # tampilan file csv tanpa `setwd`
csv1 <- read.csv("Data/csv1.csv",sep = ",")       # ini untuk membaca data dengan pemisah koma
csv2 <- read.csv("Data/csv2.csv",sep = ";")       # ini untuk membaca data dengan pemisah titik koma 
head(csv2,3)                                      # mencetak hasil dari `data1` 
```

R dapat membuat file csv dari data frame yang ada. Fungsi `write.csv()` digunakan untuk membuat file csv. File ini dibuat di working directory.

```{r, echo=T}
write.csv(csv2,"Data/csv3.csv")
```


## Membaca/Menulis Excel

Microsoft Excel adalah program spreadsheet yang paling banyak digunakan yang menyimpan data dalam format .xls atau .xlsx. R dapat membaca file-file ini secara langsung menggunakan beberapa packages (paket) khusus excel. Kita akan menggunakan package `readxl`.

```{r, echo=T}
# xlsx <- read_excel(file.choose())                # tampilan file xlsx tanpa `setwd`
# install.packages("readxl")                       # menginstal package `readxl` 
library("readxl")                                  # memuat package `readxl`
xlsx1<-read_excel("Data/xlsx1.xlsx",sheet=1)       # membaca/impor data xlsx dari PC
head(xlsx1,3)        
```

Untuk menulis data frame yang ada ke dalam file excel Anda harus menginstal package `writexl`.
```{r, echo=T}
# install.packages("writexl")                      # menginstal  package `readxl`
library("writexl")                                 # memuat package `readxl` 
writexl::write_xlsx(xlsx1,"Data/xlsx2.xlsx")       # memeriksa output di working directory Anda
```


## Membaca/Menulis TXT dan RDS

Salah satu tugas paling umum yang kita lakukan adalah membaca data dari file CSV dan XLSX. Namun, proses membaca data bisa melambat untuk file CSV atau XLSX yang besar. Salah satu trik yang rapi adalah membaca data dan menyimpannya sebagai file TXT atau file biner R (RDS). Untuk mengimpor file TXT, kita menggunakan `read.table()` dan untuk mengimpor file RDS kita dapat menggunakan `readRDS()`.

```{r, echo=T}
# txt1 <- read.table(file.choose())                # tampilan file TXT tanpa `setwd`
txt1 <- read.table("Data/txt1.txt")                # membaca/memuat format TXT (notepad)
txt1 <- source("Data/txt1.Rdmpd")                  # membaca/memuat format TXT (Rdmpd)
rds1 <- readRDS("Data/rds1.rds")                   # membaca/memuat format RDS biner
ascii1 <- readRDS("Data/ascii1.rds")               # membaca/memuat format ASCII biner
```

Untuk menyimpan data sebagai file TXT kita dapat menggunakan fungsi `write.table()`, dan untuk file biner R (RDS) kita dapat menggunakan fungsi `saveRDS()`. Fungsi-fungsi tersebut banyak digunakan oleh R sendiri, sebagai contoh untuk menyimpan data meta untuk suatu package dan untuk menyimpan basis data `help.search:` ekstensi file `.rds` paling sering digunakan. Format ini dapat berupa biner atau ASCII. Biner lebih padat, sementara ASCII akan lebih efisien dengan sistem kontrol versi seperti [Git](https://git-scm.com/).

```{r, echo=T}
data <- read.csv("Data/csv1.csv",sep = ",")        # membaca/mengimpor data dari PC Anda

write.table(data,"Data/txt2.txt")                  # meyimpan dalam format TXT (notepad)
dump("data", "Data/txt2.Rdmpd")                    # meyimpan dalam format TXT (Rdmpd)
saveRDS(data, "Data/rds2.rds")                     # menyimpan suatu objek dalam format RDS biner
saveRDS(data, "ascii2.rds", ascii=TRUE)            # menyimpan suatu objek dalam format RDS ASCII
```


## Membaca/Menulis XML

XML adalah suatu format file yang membagikan format file dan data dari World Wide Web (www), intranet, dan di tempat lain menggunakan teks ASCII standar. XML adalah singkatan dari Extensible Markup Language, [lebih lanjut tentang XML](https://www.youtube.com/embed/KeLiQXqVgMI). XML berisi tag markup, mirip dengan [HTML](https://www.youtube.com/embed/rs5hz_oZywI). Tag markup di xml menggambarkan arti data yang terkandung dalam file tersebut, tetapi tidak seperti HTML di mana tag markup menggambarkan struktur halaman. Anda dapat membaca suatu file xml di R menggunakan package "XML". File XML dibaca oleh R menggunakan fungsi `xmlParse()`. File itu disimpan sebagai daftar (list) di R.

```{r, echo=T}
library("XML")                                     # memuat package yang dibutuhkan untuk membaca file XML
library("methods")                                 # memuat paket lainnya yang dibutuhkan.
result <- xmlParse(file = "Data/xml1.xml")         # memberikan nama file input ke fungsi
print(result)                                      # Mencetak hasilnya
```

Untuk menangani data secara efektif dalam file besar, kita membaca data dalam file `XML` sebagai suatu data frame. Kemudian memproses data frame untuk analisis data.

```{r, echo=T}
xmldataframe <- xmlToDataFrame(result)             # mengonversi file input `xml` ke bentuk data frame
head(xmldataframe,3)                               # Mencetak hasilnya
```

Buat file XML dengan menyalin [data ini](https://github.com/Bakti-Siregar/dataset/blob/master/Bookdown-Data-Science-for-Beginners/xml1.xml) ke editor teks seperti notepad. Simpan file dengan ekstensi `.xml` dan pilih jenis file sebagai all files(.).


## Membaca/Menulis JSON

File JSON menyimpan data sebagai teks dalam format yang dapat dibaca oleh manusia. JSON adalah singkatan dari JavaScript Object Notation. R dapat membaca file JSON menggunakan package rjson. [Lebih lanjut tentang JSON](https://www.youtube.com/embed/2q5bAvNlBsc)

```{r, echo=T}
library("rjson")                                   # memuat package untuk membaca file JSON
json1 <- fromJSON(file= "Data/json1.json")         # memberikan nama file input ke fungsi
print(json1)                                       # Mencetak hasilnya
```

Kita dapat mengonversi data yang diekstraks di atas ke bentuk data frame R untuk analisis lebih lanjut menggunakan fungsi `as.data.frame()`

```{r, echo=T}
json_data_frame <- as.data.frame(json1)            # mengonversi file JSON ke bentuk data frame
head(json_data_frame,3)                            # Mencetak hasilnya
```

## Membaca Data dari Web

Banyak situs web yang menyediakan data untuk digunakan oleh penggunanya. Dengan menggunakan program R, kita dapat mengekstrak data tertentu dari situs web tersebut secara terprogram. Di bagian ini, saya memberikan contoh cara mengimpor data dari repositori github, tetapi Anda dapat melakukan hal yang serupa pada situs web atau repositori lainnya.

### CSV:
```{r, echo=T}
web_csv <- read.csv("https://github.com/Bakti-Siregar/dataset/raw/master/Bookdown-Data-Science-for-Beginners/csv1.csv")
head(web_csv,3)
```

### XLSX:
```{r, echo=T}
library(rio)                                       # package ini untuk mengimpor data dari github
install_formats()                                  # mungkin Anda perlu menginstal packages yang disarankan yang belum terinstal
```

```{r, echo=T}
web_xlsx <-rio::import("https://github.com/Bakti-Siregar/dataset/blob/master/Bookdown-Data-Science-for-Beginners/xlsx1.xlsx?raw=true")
head(web_xlsx,3)
```

### LAINNYA:
```{r, eval=FALSE}
web_txt <- read.table("type URL/Web.txt here")     # membaca/memuat format TXT (notepad) dari web
web_rds <- readRDS("type URL/Web.rds here")        # membaca/memuat format RDS dari web
web_ascii <- readRDS("type URL/Web.ascii here")    # membaca/memuat format ASCII dari web

web_xml<- xmlParse("type URL/Web.xml here")        # membaca/memuat format XML dari web 
xmlToDataFrame(web_xml)                            # mengonversi file xml input ke bentuk data frame

web_json <- fromJSON("type URL/Web.json here")     # membaca/memuat format JSON dari web
as.data.frame(web_json)                            # mengonversi file JSON ke bentuk data frame
```


## Sistem Basis Data dengan R

Data tersebut adalah sistem basis data relasional yang disimpan dalam format yang dinormalisasi. Jadi, untuk melakukan komputasi statistik kita akan memerlukan query Sql yang lebih lanjut dan sangat kompleks. Tetapi R dapat terhubung ke banyak basis data relasional dengan mudah seperti MySql, Oracle, server Sql, dll serta mengambil catatan sebagai data frame dari basis data tersebut. Setelah data itu tersedia di lingkungan (environment) R, maka akan menjadi kumpulan data R normal dan dapat dimanipulasi atau dianalisis menggunakan semua package dan fungsi yang kuat.

**Catatan:** Kita akan mempelajari bagian ini lebih mendalam di "Sistem Basis Data dengan R".


<!--chapter:end:04-Interface-Data.Rmd-->

# Manipulasi Data dengan R {#Manipulasi-Data-dengan-R}
*** 

Salah satu keterampilan paling mendasar yang harus dimiliki seorang Data Scientist adalah memanipulasi data. Untuk menjadi seseorang yang sangat efektif, Anda harus ahli dalam memanipulasi data penting. Hal ini perlu diperhatikan karena sebagian besar pekerjaan Anda akan melibatkan [pengambilan dan pembersihan data](https://www.forbes.com/sites/gilpress/2016/03/23/data-preparation-most-time-consuming-least-enjoyable-data-science-task-survey-says/#4b432fa66f63).

Pada bagian ini, Anda akan mempelajari bagaimana memanipulasi data dengan mudah menggunakan R. Kita akan membahas fungsi-fungsi manipulasi data mendasar yang sebagian besar akan Anda gunakan untuk memanipulasi data Anda.

* `read_csv()` Mengimpor data (Anda bisa menggunakan fungsi lainnya)
* `str()` Struktur Data
* `apply()` Untuk mengecek dan mengganti data yang hilang.
* `select()` Memilih kolom yang akan disertakan.
* `filter()` Memilih subset yang ada di dalam data.
* `arrange()` Mengurutkan data, berdasarkan ukuran dari variabel kontinu, berdasarkan tanggal, atau menurut abjad.
* `rename()` Mengganti nama kolom.
* `mutate()` Membuat kolom baru di dalam data, atau mengganti kolom yang sudah ada.
* `bind_rows()` Menggabungkan dua data frame menjadi satu, menggabungkan data dari kolom-kolom dengan nama yang sama.
* `group_by()` Mengelompokkan data berdasarkan variabel kategorikal.
* `summarize()` Meringkas, atau mengagregat (untuk setiap kelompok jika mengikuti `group_by`). Sering digunakan bersama fungsi sebagai berikut:
  * `mean()` Menghitung rata-rata.
  * `median()` Menghitung median.
  * `max()` Mencari nilai maksimum.
  * `min()` Mencari nilai minimum.
  * `sum()` Menambahkan semua nilai secara bersamaan.
  * `n()` Menghitung jumlah record.

Saya menyarankan Anda untuk menginstal package [`tidyverse`](https://www.tidyverse.org/packages/). Karena inti dari `tidyverse` mencakup packages yang cendrung Anda gunakan dalam analisis data sehari-hari.

```{r, eval=FALSE}
install.packages("tidyverse")
```

Kita sebagian besar akan bekerja dengan dua package yang sangat berguna yang dikembangkan oleh [Hardley Wickham](http://hadley.nz/), kepala scientist di RStudio:

* [`readr`](https://readr.tidyverse.org/) Untuk membaca dan menulis CSV dan file teks lainnya.
* [`dplyr`](https://dplyr.tidyverse.org/) Untuk memproses dan memanipulasi data.

## Impor Data

[Data](https://bookdown.org/BaktiSiregar/data-science-for-beginners/datasets.html#pfizer-and-fda) yang akan kita gunakan pada bagian ini adalah `pfizer.csv` dan `fda.csv`, silakan unduh dan tempatkan di desktop Anda. Sebagai opsional, Anda dapat memuat data ke sesi R saat ini dengan memilih `Import Dataset>From Teks File...` di tab Environment. Tapi, dalam hal ini kita akan menggunakan fungsi `read_csv()` dari package `readr`. Salinlah kode berikut ke skrip Anda dan jalankan:

```{r, echo=T, results='hide', message=FALSE}
suppressPackageStartupMessages(library(tidyverse))# memuat tidyverse
#setwd("C:/Users/Bakti/Desktop/")                 # ingatlah untuk mengatur working directory Anda
pfizer <- read_csv("Data/pfizer.csv")             # memuat data `pfizer` 
```

```{r, echo=T, results='hide', message=FALSE}
fda <- read_csv("Data/fda.csv")
```

## Struktur Data

Perhatikan bahwa Anda akan membutuhkan pemahaman yang kuat mengenai tipe-tipe data mendasar dan struktur data dan bagaimana cara mengoprasikannya. Fungsi `str()` akan memberi tahu lebih banyak mengenai kolom dalam data Anda, termasuk tipe datanya. Salinlah kode berikut ke skrip Anda dan jalankan:

```{r, echo=T, results='hide'}
str(pfizer)                                       # melihat struktur dari data `pfizer`
str(fda)                                          # melihat struktur dari data `fda`
```

Sangat penting untuk dipahami karena ini adalah objek yang akan Anda manipulasi di R setiap saat. Jika Anda perlu mengubah tipe data untuk kolom apa pun, gunakan fungsi-fungsi di bawah ini:

* `as.character()` mengubah ke teks string.
* `as.numeric()` mengubah ke angka.
* `as.factor()` mengubah ke variabel kategorikal.
* `as.integer()` mengubah ke bilangan bulat.
* `as.Date()` mengubah ke tanggal.
* `as.POSIXct()` mengubah ke tanggal dan waktu penuh.

Misalnya, tambahkan kode berikut ke skrip Anda untuk mengubah total konversi dalam data `pfizer` ke variabel numerik (yang memungkinkannya menyimpan nilai desimal, jika ada).

```{r, echo=T, results='hide'}
pfizer$total <- as.numeric(pfizer$total)          # konversi total ke variabel numerik
str(pfizer$total)                                 # mari periksa struktur datanya lagi
```

## Missing Value

Tidak seperti pemrograman biasa, ketika bekerja dengan data sesungguhnya, Anda mungkin menemukan **nilai yang hilang:** pengukuran yang tidak terekam/tersimpan/dll. R memiliki mekanisme yang cukup canggih untuk menangani nilai-nilai yang hilang. Ini membedakan antara jenis berikut:

* `NA` : Not Available (Nilai NA juga memiliki kelas, ada bilangan bulat NA, karakter NA, dll).
* `NaN` : Not a Number (Nilai NaN juga merupakan NA tetapi NA bukan merupakan NaN)

Temukan nilai yang hilang di kolom dataframe `pfizer`

```{r, echo=T, results='hide'}
is.na(pfizer)                                     # cara untuk mengecek NA
sum(is.na(pfizer))                                # menghitung jumlah NA
apply(is.na(pfizer),2, which)                     # indeks NA (hanya df)
which(complete.cases(pfizer))                     # mengidentifikasi nilai lengkap yang diamati
```

Mekanisme yang lebih umum adalah menghapusnya secara manual:
```{r, echo=T, results='hide'}
clean.vector<- na.omit(pfizer$first_name)         # bersihkan/hapus NA di vektor
clean.df <- na.omit(pfizer)                       # berishkan/hapus NA di dataframe
apply(is.na(clean.df),2, which)                   # pastikan jika ada nilai yang hilang
```

## Mengganti Nilai yang Hilang

Kita juga dapat mengganti nilai yang hilang dengan rata-rata (median). Praktik yang baik adalah dengan membuat dua variabel terpisah untuk mean. Setelah dibuat, kita dapat mengganti nilai yang hilang dengan variabel yang baru dibentuk. Mari unggah dan memeriksa data yang hilang.

```{r, echo=T, results='hide'}
PATH <- "https://raw.githubusercontent.com/Bakti-Siregar/dataset/master/Bookdown-Data-Science-for-Beginners/Missing_Values.csv"
titanic <- read.csv(PATH, sep = ",")
list_na <- colnames(titanic)[ apply(titanic, 2, anyNA) ]
list_na
```

Dalam hal ini, kita tidak menghapus semua nilai yang hilang, tetapi kita menggunakan metode `apply()` untuk menghitung rata-rata kolom dengan `NA`. Pertama, kita perlu menghitung rata-rata dengan argumen `na.rm = TRUE`. Argumen ini wajib karena kolom memiliki data yang hilang dan ini memberi tahu R untuk mengabaikannya.

```{r, echo=T, results='hide'}
average_missing <- apply(titanic[,colnames(titanic) %in% list_na],
                         2,
                         mean,
                         na.rm =  TRUE)
average_missing
```

**Penjelasan Kode:** Terdapat 4 argumen di metode apply yang kita jalankan.

* `df` titanic[,colnames(titanic) %in% list_na]. Kode ini akan mengembalikan nama kolom dari objek list_na (mis. "age" dan "fare").
* `2` Menghitung fungsi pada kolom.
* `mean` Menghitung rata-rata.
* `na.rm = TRUE` Menolak nilai yang hilang.

Selanjutnya, kita dapat mengganti nilai-nilai `NA`. Fungsi mutate dari library `dplyr` berguna untuk membuat variabel baru. Kita tidak perlu mengubah kolom asli, jadi kita dapat membuat sebuah variabel baru tanpa `NA`. Fungsi mutate mudah digunakan, kita hanya perlu memilih nama variabel dan menentukan bagaimana cara membuat variabel tersebut. Berikut ini kode lengkapnya:

```{r, eval=FALSE}
library(dplyr)
titanic_replace <- titanic %>%
mutate(age  = ifelse(is.na(Age), average_missing[1], Age),
fare = ifelse(is.na(Fare), average_missing[2], Fare))
sum(is.na(titanic_replace$Age))
sum(is.na(titanic_replace$Fare))
```

Kolom usia asli memiliki 86 nilai yang hilang sementara variabel yang baru dibuat telah mengganti nilai yang hilang dengan rata-rata usia variabel. Anda dapat mencoba sendiri mengganti penelitian yang hilang dengan nilai median juga.

## Memilih Data

Pada bagian ini, Anda akan mempelajari bagaimana cara memilih atau mengelompokkan kolom dataframe berdasarkan nama dan posisi menggunakan fungsi R yaitu `select()` dalam package [`dplyr`](https://dplyr.tidyverse.org/reference/summarise.html). Anda akan belajar cara menggunakan fungsi berikut ini:

* `pull()` mengekstrak nilai kolom sebagai sebuah vektor. Kolom bunga dapat ditentukan berdasarkan nama atau indeks.
* `select()` mengekstrak satu atau beberapa kolom sebagai tabel data. Fungsi ini juga dapat menghapus kolom dari data frame.
* `select_if()` Memilih kolom berdasarkan kondisi tertentu. Seseorang dapat menggunakan fungsi ini, misalnya untuk memilih kolom jika numerik.
* **Fungsi Pembantu:** `starts_with()`, `ends_with()`, `contains()`, `matches()`: Pilihlah kolom/variabel berdasarkan namanya.

```{r, echo=T, results='hide'}
library(tidyverse)                                # muat `tidyverse`, yang termasuk dalam `dplyr`
pfizer %>% pull(state) %>% head()                 # ekstrak nilai kolom `state` sebagai vektor
pfizer %>% select(1:3)                            # memilih kolom 1 sampai 3
pfizer %>% select(1,3)                            # memilih kolom 1 dan 3, tidak termasuk 2
pfizer %>% select(state:total)                    # memilih semua kolom dari `state` sampai `total`
pfizer %>% select(state,total)                    # memilih kolom berdasarkan nama variabel
pfizer %>% select_if(is.numeric)                  # hanya memilih kolom numerik
pfizer %>% select_if(is.character)                # hanya memilih kolom karakter
pfizer %>% select(starts_with("first"))           # hanya memilih kolom yang dimulai dengan `first`
pfizer %>% select(ends_with("name"))              # hanya memilih kolom yang diakhiri dengan `name`
pfizer %>% select(contains("rst"))                # memilih kolom yang namanya mengandung `rst`
pfizer %>% select(matches("_"))                   # memilih kolom yang namanya cocok dengan reguler
pfizer %>% select(-(state:total))                 # menghapus semua kolom dari `state` sampai `total`
pfizer %>% select(-state, -total)                 # menghapus kolom `state` dan `total`
```

## Menyaring dan Mengurutkan Data

Sekarang kita akan `filter()` dan `arrange()` data dengan cara tertentu. Untuk setiap contoh berikut, salin kode berikut ke dalam skrip Anda, dan lihat hasilnya. Perhatikan bagaimana kita membuat objek baru untuk menampung data yang diproses.

**Contoh 1:** Temukan dokter di California yang dibayar $10.000 atau lebih oleh Pfizer untuk menjalankan "Professional Advising"!

```{r, echo=T, results='hide'}
ca_expert_10000 <- pfizer %>%                     # memuat semua `pfizer`    
  filter(state == "CA" &                          # memuat semua `pfizer` disaring berdasarkan `state`
         total >= 10000 &                         # dan juga disaring berdasarkan `total` lebih besar sama dengan 10000
         category == "Professional Advising")     # kemudian disaring berdasarkan `category`
ca_expert_10000                                   # cetak hasilnya
```

**Contoh 2:** Sekarang tambahkan daftar urutan secara menurun pembayaran yang diterima oleh dokter di bagian akhir kode!

```{r, echo=T, results='hide'}
ca_expert_10000 <- pfizer %>%                     # memuat semua `pfizer`    
  filter(state == "CA" &                          # disaring berdasarkan `state`di California
         total >= 10000 &                         # dan juga disaring berdasarkan `total` lebih besar sama dengan 10000
         category == "Professional Advising")%>%  # kemudian disaring berdasarkan `category`
  arrange(desc(total))                            # mengurutkan secara menurun pembayaran yang diterima
ca_expert_10000                                   # cetak hasilnya

# arrange((total))                                # mengurutkan secara menaik telah ditetapkan sebagai R default
```

**Contoh 3:** Temukan dokter di California atau New York yang dibayar $10.000 atau lebih oelh Pfizer untuk menjalankan "Professional Advising"!

Perhatikan bahwa, dalam kasus ini kita menggunakan `|` operator Boolean, dan tanda kurung di sekitar bagian kueri tersebut. Ini memastikan bahwa bagian kueri ini dijalankan terlebih dahulu. Lihat apa yang terjadi jika Anda mengecualikan mereka.

```{r, echo=T, results='hide'}
ca_ny_expert_10000 <- pfizer %>%                  # memuat semua `pfizer`    
  filter((state == "CA" | state == "NY")  &       # disaring berdasarkan `state` California atau New York
         total >= 10000 &                         # dan juga disaring berdasarkan `total` lebih besar sama dengan 10000
         category == "Professional Advising")%>%  # kemudian disaring berdasarkan `category`
  arrange(desc(total))                            # mengurutkan secara menurun pembayaran yang diterima
ca_ny_expert_10000                                # cetak hasilnya
```

**Contoh 4:** Temukan dokter di negara bagian selain California yang dibayar $10.000 atau lebih oleh Pfizer untuk menjalankan "Professional Advising"!

```{r, echo=T, results='hide'}
not_ca_expert_10000 <- pfizer %>%                 # memuat semua `pfizer`    
  filter(state != "CA" &                          # disaring berdasarkan `state` selain California
         total >= 10000 &                         # dan juga disaring berdasarkan `total` lebih besar sama dengan 10000
         category == "Professional Advising")%>%  # kemudian disaring berdasarkan `category`
  arrange(desc(total))                            # mengurutkan secara menurun pembayaran yang diterima
not_ca_expert_10000                               # cetak hasilnya
```

**Contoh 5:** Temukan 20 dokter di empat negara bagian terbesar (CA, TX, FL, NY) yang dibayar paling tinggi untuk "Expert-Led Forums"!

```{r, echo=T, results='hide'}
ca_ny_tx_fl_prof_top20 <- pfizer %>%
  filter((state == "CA" | 
          state == "NY" |
          state == "TX" | 
          state == "FL") &
          category == "Expert-Led Forums") %>%
  arrange(desc(total)) %>%
  head(20)
ca_ny_tx_fl_prof_top20
```

**Contoh 6:** Saring data `pfizer` untuk semua pembayaran untuk menjalankan "Expert-Led Forums" atau untuk "Professional Advising", dan urutkan nama dokter berdasarkan abjad (nama belakang, kemudian nama depan)

```{r, echo=T, results='hide'}
expert_professional_advice <- pfizer %>%
  filter(category == "Expert-Led Forums" | 
         category == "Professional Advising") %>%
  arrange(last_name, first_name)
expert_professional_advice
```

## Mengganti Nama dan Mengubah (Mutate)

Di bagian ini, Anda akan belajar bagaimana mengganti nama kolom dari sebuah data frame di R. Kemudian, Anda akan belajar bagaimana cara menghitung dan menambah variabel baru ke data frame di R. Anda akan belajar fungsi-fungsi R berikut ini dari package R yaitu dplyr:

* `rename()` Kode ini digunakan untuk mengganti nama kolom dari sebuah data frame di R. 
* `mutate()` Menghitung dan menambah variabel baru ke dalam sebuah tabel data. Hal ini tidak menghilangkan variabel yang ada.
* `transmute()` Menghitung kolom baru tetapi menghilangkan variabel yang ada.

```{r, echo=T, results='hide'}
# Mengganti nama kolom dari data `pfizer` dengan fungsi-fungsi dasar R:
names(pfizer)[names(pfizer) == "org_indiv"] <- "rename1"
names(pfizer)[1] <- "rename2"
names(pfizer)[names(pfizer)==names(pfizer)] <- c("rename3",
                                                 "rename4",
                                                 "first_name",
                                                 "last_name",
                                                 "city",
                                                 "state",
                                                 "category",
                                                 "cash",
                                                 "other",
                                                 "total")
# Mengganti nama kolom dari data `pfizer` dengan `dplyr::rename()`:
pfizer %>% 
  rename(
    org_indiv = rename3 ,
    first_plus = rename4  
    )
# Menambahkan kolom baru (year*) dengan mempertahankan data `fda` yang ada:
letters_year <- fda %>%
  mutate(year = format(issued, "%Y")) %>%
  group_by(year)
letters_year
# Menambahkan kolom baru (year*) dan (last_name*) dengan menghilangkan data `fda` yang ada:
fda %>%
  transmute(
    year = format(issued, "%Y"),
    last_name = name_last  
    )
```

## Menggabungkan Data

Ada juga beberapa fungsi gabungan di `dplyr` untuk menggabungkan data dari dua data frame. Berikut ini adalah fungsi yang paling berguna:

* `inner_join()` Mengembalikan nilai dari kedua tabel hanya jika ada kecocokan.
* `left_join()` Mengembalikan semua nilai dari tabel yang pertama disebutkan, ditambah nilai dari tabel kedua yang cocok.
* `semi_join()` Menyaring tabel yang pertama disebutkan untuk mendapatkan nilai yang memiliki kecocokan dengan tabel kedua.
* `anti_join()` Menyaring tabel yang pertama disebutkan untuk mendapatkan nilai yang tidak memiliki kecocokan dengan table kedua.

Sebagai ilustrasinya, gabungan ini akan menemukan dokter yang dibayar oleh `Pfizer` untuk menjalankan Expertp-Led Forums yang juga menerima surat peringatan dari `fda`:

```{r, echo=T, results='hide'}
expert_warned_inner <- inner_join(pfizer, fda, 
                                  by=c("first_name" = "name_first", 
                                       "last_name" = "name_last")) %>%
                                  filter(category=="Expert-Led Forums")

expert_warned_semi <- semi_join(pfizer, fda, 
                                by=c("first_name" = "name_first", 
                                     "last_name" = "name_last")) %>%
                                filter(category=="Expert-Led Forums")
```

Kode dalam `by=c()` menentukan bagaimana gabungan harus dibuat. Jika instruksi tentang bagaimana cara menggabungkan tabel tidak disediakan, `dplyr` akan mencari kolom dengan nama yang cocok, dan melakukan penggabungan berdasarkan hal tersebut. Perbedaan antara dua gabungan di atas adalah yang pertama berisi semua kolom dari kedua data frame, sedangkan yang kedua hanya memberikan kolom dari data frame `pfizer`.

Dalam praktiknya, mungkin Anda ingin `inner_join`dan kemudian menggunakan fungsi select dari `dplyr` untuk memilih kolom yang ingin Anda pertahankan, misalnya:

```{r, echo=T, results='hide'}
expert_warned <- inner_join(pfizer, fda, 
                            by=c("first_name" = "name_first", 
                                 "last_name" = "name_last")) %>%
                            filter(category=="Expert-Led Forums") %>%
                            select(last_name, 
                                   city, 
                                   state, 
                                   total, 
                                   issued)

expert_warned <- inner_join(pfizer, fda, 
                            by=c("first_name" = "name_first",
                                 "last_name" = "name_last")) %>%
                            filter(category=="Expert-Led Forums") %>%
                            select(2:5,10,12)
```

[Klik di sini](https://www.guru99.com/r-dplyr-tutorial.html) untuk referensi yang lebih berguna untuk mengelola gabungan dengan dplyr.

## Kelompok dan Ringkasan

Bagian ini memperkenalkan cara menghitung ringkasan statistik dengan mudah di R menggunakan package `dplyr`. Anda akan belajar, bagaimana:

* Menghitung ringkasan statistik untuk data yang tidak dikelompokkan, serta untuk data yang dikelompokan menurut satu atau beberapa variabel. Fungsi R: `summarise()` dan `group_by()`.
* Meringkas beberapa kolom variabel. Fungsi R:
  * `summarise_all()` Menerapkan fungsi ringkasan ke setiap kolom dalam data frame.
  * `summarise_at()` Menerapkan fungsi ringkasan ke kolom tertentu yang dipilih dengan vektor karakter.
  * `summarise_if()` Menerapkan fungsi ringkasan ke kolom yang dipilih dengan fungsi yang menampilkan TRUE
 
**Contoh 7:** Hitunglah total pembayaran data `pfizer`, dengan urutan negara bagian secara menurun!

```{r, echo=T, results='hide'}
state_sum <- pfizer %>%
  group_by(state) %>%
  summarize(sum = sum(total)) %>%
  arrange(desc(sum))

state_sum
```

**Contoh 8:** Hitunglah beberapa ringkasan statistik tambahan dari data `pfizer`, dengan urutan negara bagian secara menurun!

```{r, echo=T, results='hide'}
state_summary <- pfizer %>%
  group_by(state) %>%
  summarize(sum = sum(total), 
        average = mean(total), 
         median = median(total),
            min = min(total),
            max = max(total),
            count = n()) %>%
  arrange(desc(sum))

state_summary
```

**Contoh 9:** Kelompokkan dan rangkum data `pfizer` untuk beberapa kategori naik!

```{r, echo=T, results='hide'}
state_summary <- pfizer %>%
  group_by(state, category) %>%
  summarize(sum = sum(total), 
        average = mean(total), 
         median = median(total),
            min = min(total),
            max = max(total),
            count = n()) %>%
  arrange(state, category)

state_summary
```

**Contoh 10:** Saring data `fda` untuk surat-surat yang telah dikirim dari awal tahun 2006 dan seterusnya dan rangkum!

```{r, echo=T, results='hide'}
year_summary <- fda %>%
  filter(issued >= "2005-01-01") %>%
  arrange(issued) %>%
  mutate(year = format(issued, "%Y")) %>%
  group_by(year) %>%
  summarize(letters=n())

year_summary
```

**Waspada:** Menggunakan kembali variabel dapat menyebabkan hasil yang tidak dapat diharapkan, tetapi jangan khawatir. R akan memberikan peringatan seperti `summarise() ungrouping output (override with .groups argument)`.

## Membagi Data

Seperti yang sudah saya sampaikan pada bab Pemrograman R tentang menulis fungsi untuk membagi data latihan dan data percobaan. Di sini, kita akan mempelajari lebih lanjut tentang bagaimana menggunakan beberapa packages untuk membagi data. Karena bagian ini sangat penting sebagai seorang data scientist khususnya ketika Anda menerapkan tugas [Machine Learning](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Manipulation.html) untuk menganalisis data. Pada bagian ini biasanya kita perlu membagi dataset antara set latihan dan set percobaan. Set latihan memungkinkan algoritme untuk belajar dari data. untuk menguji kinerja model kita, kita dapat menggunakan set percobaan untuk mengembalikan ukuran kinerja. Jadi, mari kita lihat beberapa packages yang dapat Anda gunakan untuk membagi data:

### dplyr

Anda dapat menggunakan `dplyr` untuk ini, membuat jadi sangat sederhana. itu memang memerlukan variabel id dalam dataset Anda, yang mana ini merupakan ide yang bagus, tidak hanya untuk membuat set-set tetapi juga untuk keterlacakan selama proyek Anda. Tambahkan jika belum ada.

```{r, eval=FALSE}
library(dplyr)                                    # memuat package `dplyr`
data(mtcars)                                      # menggunakan data dari environment R
set.seed(123)                                     # untuk memastikan kita menghasilkan data yang sama
mtcars$id <- 1:nrow(mtcars)                       # menambahkan `id` jika belum ada
train<-mtcars %>% dplyr::sample_frac(.75)         # beri nama untuk set latihan
test<-dplyr::anti_join(mtcars, train, by = 'id')  # beri nama untuk set percobaan
dim(train)                                        # mengecek dimensi set latihan
dim(test)                                         # mengecek dimensi set percobaan 
```

**Catatan:** Dataset ini hanya sebagai contoh, ini tidak cocok untuk tugas machine learning karena datanya terlalu sedikit.

### caTools

Ada banyak pendekatan untuk mencapai partisi data. Untuk pendekatan yang lebih lengkap, lihat fungsi `createDataPartition` dalam package `caTools`.

```{r, eval=FALSE}
library(caTools)                                  # memuat package `caTools`
data(mtcars)                                      # menggunakan data dari environment R
set.seed(123)                                     # untuk memastikan kita mendapatkan data yang sama
smp_size <- floor(0.75 * nrow(mtcars))            # 75% dari ukuran sampel
train_ind <- sample(seq_len(nrow(mtcars)), 
                    size = smp_size)
train <- mtcars[train_ind, ]                      # memberi nama untuk set latihan
test <- mtcars[-train_ind, ]                      # memberi nama untuk set percobaan
dim(train)                                        # mengecek dimensi set latihan
dim(test)                                         # mengecek dimensi set percobaan
```

### caret

Packages hebat lainnya yang dapat Anda gunakan untuk membagi dataset adalah `caret`.

```{r, eval=FALSE, message=F}
library(caret)                                    # memuat package `caret`

data(mtcars)                                      # menggunakan data dari environment R
set.seed(123)                                     # untuk memastikan kita mendapatkan data yang sama
intrain<-createDataPartition(mtcars$mpg,
                             p=0.75,list=FALSE)
train<-mtcars[intrain,]
test<-mtcars[-intrain,]
dim(train)                                        # mengecek dimensi set latihan
dim(test)                                         # mengecek dimensi set percobaan
```

[**Lebih lanjut**](https://www.datanovia.com/en/courses/data-manipulation-in-r/)

<!--chapter:end:05-Manipulasi-Data-dengan-R.Rmd-->

# Eksplorasi Data Analisis {#Eksplorasi-Data-Analisis}
***

**Analisis Data Eksplorasi (ADE)** adalah pendekatan analisis data untuk meringkas dan memvisualisasikan karakteristik penting dari data. ADE dapat dianggap sebagai asumsi bebas, biasanya dilakukan dalam perilaku analisis data. ADE juga dikenal sebagai analitik visual atau statistik deskriptif. ADE juga merupakan praktik pengamatan, dan mengeksplorasi data, sebelum Anda menekankan beberapa hipotesis, menyesuaikan prediktor, dan tujuan lainnya pada statistik inferensial. ADE biasanya mencakup penghitungan ringkasan statistika sederhana yang menangkap beberapa properti yang diminati dalam data dan visualisasi.

Seseorang yang bekerja dengan data, salah satu aktivitasnya yang paling menarik adalah mengeksplorasi dataset yang baru. Anda harus memehami variabel apa saja yang Anda miliki, berapa banyak records yang ada di dalam dataset, berapa banyak data yang hilang, apa struktur variabelnya, apa hubungan variabelnya, dan masih banyak lagi. Oleh karena itu, pada bagian ini akan kita akan menampilkan beberapa poin penting dalam ADE dasar sebagai berikut:

* Bagaimana mengeksplorasi: dengan statistik ringkasan, atau secara visual?
* Berapa banyak variabel yang dianalisis secara bersamaan: univariat, bivariat, atau multivariat?
* Apa tipe dari variabel: kategorikal atau kontinu?

Pada bagian ini, kita menggunakan [dataset Students](https://raw.githubusercontent.com/Bakti-Siregar/dataset/master/Bookdown-Data-Science-for-Beginners/students.csv), unduh dan simpan di komputer (PC) Anda .

## Kualitatif

Variabel kualitatif (kategorikal), yang disebut data `faktor` atau `karakter` di R, menghadirkan tantangan-tantangan unik dalam perselisihan data (data wrangling). Perhatikan bahwa: data kategorikal tidak cocok untuk operasi matematika apapun, jadi jangan menerimanya. Kita tidak dapat menggunakan sum, atau bahkan sort, kita hanya dapat menghitungnya. Dengan demikian, ringkasan dari variabel-variabel kategorikal akan selalu dimulai dengan menghitung frekuensi setiap kategori.

Variabel kategorikal dapat dibagi menjadi:

* **Kategorikal Nominal:** data yang levelnya adalah label atau deskripsi, dan yang tidak dapat diurutkan. 
data yang levelnya adalah label atau deskripsi, dan yang tidak dapat dipesan. Contoh variabel nominal adalah jenis kelamin, sekolah, dan pertanyaan dengan jawaban ya/tidak. Biasanya juga disebut variabel "kategorikal nominal" atau "kualitatif", dan tingkat variabel kadang-kadang disebut "kelas" atau "kelompok". 

* **Kategorikal Ordinal:** dapat disusun atau diberi peringkat dalam urutan yang logis, tetapi interval antara level variabel belum tentu diketahui. Pengukuran subyektif seringkali merupakan variabel ordinal. Salah satu contoh adalah dengan meminta orang memberikan empat urutan peringkat ke suatu item berdasarkan prioritas. Contoh lainnya adalah meminta orang untuk menilai beberapa item berdasarkan skala peringkat Likert:"Pada skala satu sampai lima, apakah Anda setuju atau tidak setuju dengan pernyataan ini?". Contoh ketiga adalah tingkat pendidikan untuk orang dewasa, misalnya dengan mempertimbangkan "dibawah sekolah menengah", "sekolah menengah", "gelar asosiasi/sarjana", dll.

### Kategorikal Univariat

Analisis univariat mengeksplorasi variabel (atribut) satu per satu. Variabel dapat berupa kategorikal atau numerik. Ada perbedaan teknik statistik dan visualisasi dari penyelidikan untuk setiap jenis variabel. Variabel numerik dapat diubah menjadi bagian kategorikal dengan proses yang disebut [binning atau diskritisasi](https://www.saedsayad.com/binning.htm). Dimungkinkan juga untuk mengubah variabel kategorikal menjadi bagian numerik dengan proses yang disebut [pengkodean](https://www.saedsayad.com/encoding.htm). Terakhir, penanganan yang tepat atas nilai yang hilang merupakan masalah penting dalam penambahan data. Sekarang, mari kita lihat cara mengeksplor data kategorikal univariat:

```{r, echo=T, results='hide', message=FALSE}
library(readr)                                     # antarmuka dataset
#setwd("C:/Users/Bakti/Desktop/")                  # mengatur working directory Anda
df= read_csv("Data/students.csv")                  # mengimpor dataset
#str(df)                                           # memeriksa struktur datanya jika diinginkan
apply(is.na(df),2, which)                          # memeriksa NA dalam data frame
df<-na.omit(df)                                    # menghapus data yang hilang
head(df,3)                                         # untuk melihat 3 baris pertama data Anda
Cat1 <- table(df$Gender)                           # menghitung frekuensinya
Cat1
```

Jika seandainya Anda menginginkan proporsi dari jumlah level, Anda dapat menggunakan `prop.table`.

```{r, echo=T, results='hide'}
prop.table(table(df$Gender))
```

### Kategorikal Bivariat

Contoh data bivariat dapat diberikan untuk membantu Anda memahami hubungan antara dua variabel dan untuk memahami ide di balik definisi dan makna analisis data bivariat. Perlu diperhatikan bahwa, dalam kasus ini, kita fokus pada variabel kategorikal.

```{r, echo=T, results='hide', message=FALSE}
library(readr)                                     # antarmuka dataset
library(dplyr)                                     # untuk memanipulasi data
library(magrittr)                                  # untuk memanipulasi data mirip dengan dplyr
Cat2<- df %>%                                      # memuat data
select(Gender, Horoscope) %>%                      # memilih vektor ke dalam matriks dan periksa
table()                                            # menghitung frekuensi kombinasi bivariat 
#prop.table()                                      # menggunakan tabel proporsi jika diinginkan
Cat2                                               # mencetak hasilnya
```

### Kategorikal Multivariat

Anda mungkin bertanya-tanya bagaimana R menangani tabel dengan lebih dari dua dimensi. Memang tidak mudah untuk menyampaikan hal ini dengan cara yang bisa dibaca oleh manusia. R menawarkan beberapa solusi: `tabel` agar lebih mudah dihitung, dan `ftable` dapat dibaca manusia.

```{r, echo=T, results='hide'}
Cat3 <- df %>%                                     # memuat data
select(Gender, Horoscope, Subject) %>%             # memilih vector ke dalam matriks dan periksalah
#table()                                           # tabel yang dapat dibaca mesin
#prop.table()                                      # menggunakan tabel proporsi jika diinginkan
ftable()                                           # tabel yang bisa dibaca manusia
Cat3                                               # mencetak hasilnya
```

## Kuantitatif

Variabel kuantitatif (Kontinu) adalah nilai-nilai dasar dalam R. Variabel-variabel tersebut disimpan sebagai numerik atau integer. Variabel kontinu menerima lebih banyak perlakuan daripada kategorikal. Kita dapat menghitung jumlah, rata-rata, median, quantiles, dan ringkasan statistik lainnya.

### Univariat Kontinu

#### Ukuran Tendensi Sentral {-}

Ukuran tendensi sentral adalah nilai tunggal yang mencoba menggambarkan sekumpulan data dengan mengidentifikasi posisi sentral dalam kumpulan data itu. Dengan demikian, ukuran tendensi sentral terkadang disebut pengukuran lokasi sentral. Ukuran tendensi sentral juga digolongkan sebagai ringkasan statistik. Mean (rata-rata) kemungkinan besar adalah ukuran tendensi sentral yang paling Anda ketahui, tetapi ada juga yang lainnya, seperti kuantil, median, mode, dan Alpha Trimmed Mean.

* **Mean(Rata-rata):** adalah ukuran tendensi sentral yang paling populer dan terkenal. mean dapat digunakan dengan data diskrit maupun kontinu, meskipun penggunaannya paling sering dengan data kontinu (lihat panduan Jenis Variabel kami untuk tipe data). Rata-rata sama dengan jumlah semua nilai dalam data set dibagi dengan seberapa banyak jumlah unit nilai dalam data set itu sendiri. Jadi, jika kita memiliki nilai di sebuah data set dan nilainya `...`, mean sampel, biasanya dinotasikan dengan (dilafalkan "x bar"), adalah:

$$
\begin{aligned}
\bar{x}&=\frac{(x_1+x_2+...+x_n)}{n}, \text{atau}\\
\bar{x}&=\frac{\Sigma{x}}{n}, \text{Sample Mean}  \\
\mu &=\frac{\Sigma{x}}{N}, \text{Population Mean}
\end{aligned}
$$

* **Kuantil:** kuantil $\alpha$ dari sampel $x$, dilambangkan dengan $x_\alpha$, didefinisikan (tidak unik) sebagai nilai di atas $100_\alpha$% dari sampel, dan di bawah $100(1-\alpha)$%. Kami menekankan bahwa kuantil sampel tidak ditentukan secara unik. Perhatikan `?quantile` untuk definisi berbeda `9(!)` yang diberikan oleh R.

* **Median:** Median dari sampel $x$, dilambangkan dengan $x_{0.5}$ dimana $\alpha=0.5$ kuantil sampel.

* **Mode:** Mode adalah nilai frekuensi yang paling sering di dataset kami. Pada histogram, mode mewakilkan batang tertinggi dalam diagram batang atau histogram. Oleh karena itu, Anda terkadang dapat menganggap mode sebagai opsi paling populer. Biasanya, mode digunakan untuk data kategorikal dimana kita ingin mengetahui kategori mana yang paling umum.

* **Alpha Trimmed Mean:** Pemangkasan rata-rata $\alpha$ dari sampel $x$, dilambangkan $\bar{x}_\alpha$ adalah rata rata dari sampel setelah menghilangkan pengamatan proporsi terbesar $\alpha$ dan pengamatan proporsi terkecil $\alpha$. Rata-rata dan median seerhana adalah contoh dari pemangkasan rata-rata $\alpha$: masing-masing $\bar{x}_0$ dan $\bar{x}_{0.5}$.

Berikut ini adalah implementasi R:

```{r, echo=T, results='hide'}
Quan <- df %>% 
select_if(is.numeric)                              # hanya memilih kolom numerik
names(Quan)                                        # memeriksa nama-nama variabel Kuantitatif
mean(Quan$Grade)                                   # rata-rata dari `Grade`
quantile(Quan$Grade)                               # kuantil dari `Grade`
median(Quan$Grade)                                 # median dari `Grade`
mode(Quan$Grade)                                   # Mode dari `Grade`
summary(Quan)                                      # ringkasan statistik sederhana dalam satu fungsi 
```

#### Skala {-}

Skala/Variabilitas data, terkadang dikenal sebagai penyebaran, dapat dianggap sebagai variabilitas sebagai berikut:

* **Varians:** Varians adalah ukuran numerik tentang bagaimana nilai data tersebar di sekitar mean. Secara khusus, varians sampel didefinisikan sebagai $s^2$. Demikian pula, varians populasi $\sigma^2$ didefinisikan dalam hal rata-rata populasi $\mu$ dan ukuran populasi $N$:
<center>
$s^2=\frac{1}{n-1}{\Sigma^n_{i=1}{(x_i-\bar{x})^2}}$
<center>
$\sigma^2=\frac{1}{N-1}{\Sigma^n_{i=1}{(x_i-\mu)^2}}$

* **Deviasi Standar:** Deviasi standar dari sebuah variabel penelitian adalah akar kuadrat dari variansinya, dilambangkan dengan $\sigma$ dan didefinisikan sebagai:
<center>
$\sigma=\sqrt{\frac{1}{N-1}{\Sigma^n_{i=1}{(x_i-\mu)^2}}}$

* **MAD:** Median Absolute Deviation (Deviasi Absolut Median) dari median, dilambangkan dengan `MAD(x)`, didefinisikan sebagai: $MAD(x):=c|x-x_{0.5}|_{0.5}$ di mana $c$ adalah konstanta, biasanya ditentukan $c=1.4826$ sehingga MAD dan $\sigma$ memiliki batas sampel yang sama besar.

* **IQR:** Inter Quantile Range (Antar Rentang Kuantil) dari sampel $x$, dilambangkan dengan $IQR(x)$, didefinisikan sebagai $IQR(x):=x_{0.75}-x_{0.25}$.

Berikut ini adalah implementasi R:

```{r, echo=T, results='hide'}
var(Quan$Grade)                                    # Varian dari `Grade`
sd(Quan$Grade)                                     # Deviasi standar dari `Grade`
mad(Quan$Grade)                                    # Deviasi Absolut Median dari `Grade`
IQR(Quan$Grade)                                    # Antar Rentang Kuantile dari `Grade`
```

#### Kecondongan (Skewness) {-}

Kecondongan atau Asimetri mengacu pada distorsi atau asimetri dalam kurva lonceng simetris, atau [distribusi normal](https://www.investopedia.com/terms/n/normaldistribution.asp), dalam dataset. Jika kurva bergeser ke kiri atau ke kanan, maka dikatakan condong. Kecondongan dapat dikuantifikasi sebagai representasi dari sejauh mana suatu distribusi bervariasi dari distribusi normal. Distribusi normal memiliki kemiringan nol, sedangkan [distribusi normal log](https://www.investopedia.com/articles/investing/102014/lognormal-and-normal-distribution.asp), sebagai contoh, akan menunjukkan beberapa derajat kemiringan ke kanan.

```{r, echo=T, results='hide'}
library(e1071)                                      # memuat e1071
skewness(Quan$Grade)                                # menerapkan fungsi kecondongan `skewness`
```

Kecondongan variabel `Quan$Grade` adalah 0.2625807. Itu menunjukkan bahwa distribusi variabel `Quan$Grade` adalah condong ke arah kanan.

#### Kurtosis {-}

Kurtosis dari distribusi normal univariat adalah 3. Membandingkan distribusi kurtosis dengan nilai ini (3) adalah umum. Distribusi dengan kurtosis kurang dari 3 disebut platykurtic, meskipun ini tidak berarti distribusinya "flat-topped" seperti yang kadang-kadang dinyatakan. Sebaliknya, ini berarti distribusi menghassilkan outlier yang lebih sedikit dan tidak terlalu ekstrim daripada distribusi normal.

```{r, echo=T, results='hide'}
kurtosis(Quan$Grade)                                # menerapkan fungsi `kurtosis`
```

Kelebihan kurtosis dari variabel `Quan$Grade` adalah -1.048464, yang menandakan bahwa distribusi variabel `Quan$Grade` adalah platykurtic. Hal ini sesuai dengan fakta bahwa histogramnya tidak berbentuk lonceng.

### Bivariat Kontinu

Saat berhadapan dengan variabel kontinu bivariat, atau multivariat, kita tentu dapat menghitung ringkasan univariat untuk setiap variabel secara terpisah. Ini bukan topik dari bagian ini, di mana kami ingin meringkas hubungan antara variabel, dan bukan di dalamnya.

#### Kovariansi {-}

Kovariansi antara dua contoh, $x$ dan $y$, dengan panjang yang sama $n$, didefinisikan sebagai
$$Cov(x,y):=\frac{1}{(n-1)}{\Sigma{(x_i-\bar{x})}{(y_i-\bar{y})}}$$

Kami menekankan ini bukanlah kovariansi yang Anda sudah pelajari di kelas probabilitas, karena ini bukan kovariansi antara dua variabel acak, melainkan antara dua sampel. Untuk alasan ini, beberapa penulis menyebutnya kovarians empiris, atau kovarians sampel.

#### Koefisien Korelasi Pearson {-}

Koefisien korelasi Pearson, yang dikenal sebagai korelasi produk momen Pearson, atau sederhananya, korelasi, dilambangkan dengan $\rho(x,y)$, didefinisikan sebagai
$$\rho(x,y):=\frac{Cov(x,y)}{\sigma_x\sigma_y}$$

Jika Anda menganggap definisi ini membingungkan, anggap saja korelasi sebagai kovariansi antara x dan y setelah mengubahnya menjadi skala `skor-z` tanpa unit.

#### Skor-Z {-}

Skor-z dari sampel $x$ didefinisikan sebagai observasi yang dinormalisasi dengan skala tengah-tengah:
$$z_i(x):=\frac{x_i-\bar{x}}{\sigma_x}$$
Jadi kita punya, $\rho(x,y):=Cov(z(x),z(y))$

```{r, echo=T, results='hide'}
cov(Quan$Grade,Quan$Sleep)                          # menerapkan fungsi `cov()`
cor(Quan$Grade,Quan$Sleep)                          # menerapkan fungsi `corr()`
zscore=(Quan$Grade-mean(Quan$Grade))/sd(Quan$Grade) # manual skor-z
```

### Multivariat Kontinu

Kovariansi adalah ringkasan sederhana dari hubungan antara dua variabel, tetapi tentu saja ini mungkin tidak mencakup keseluruhan "cerita" saat menangani lebih dari dua variabel. Ringkasan paling umum dari relasi multivariat adalah matriks kovarians, tetapi kami memperingatkan bahwa hanya relasi multivariat paling sederhana yang diringkas sepenuhnya oleh matriks ini.

#### Matriks Sampel Kovarians {-}

Diberikan pengamatan $n$ pada variabel $p$, dilambangkan dengan $x_{i,j}$ pengamatan ke-$i$ dari variabel ke-$j$. Matriks sampel kovarians, dilambangkan dengan $\hat{\Sigma}$ didefinisikan sebagai

$$\hat{\Sigma}_{k,l}:=\frac{1}{(n-1)}{\Sigma[(x_{i,k}-\bar{x}_k)(y_{i,l}-\bar{y}_l)]}$$
di mana $\bar{x}_k:=\frac{1}{n}\Sigma_ix_{i,k}$. Dengan kata lain, entri ke-k,l dalam $\hat{\Sigma}$ adalah kovarians sampel antara variabel $k$ dan $l$.

#### Matriks Sampel Korelasi {-}

[Matriks korelasi](http://users.stat.umn.edu/~helwig/notes/datamat-Notes.pdf) mengacu pada deretan angka simetris.
Matriks korelasi: R

\[R = \begin{pmatrix}    1   & Y_{12} & Y_{13} & .. & Y_{1p}\\
                      Y_{21} &    1   & Y_{23} & .. & Y_{2p}\\ 
                      Y_{31} & Y_{32} &    1   & .. & Y_{3p}\\  
                         :   &    :   &    :   &    &   :   \\
                      Y_{p1} & Y_{p2} & Y_{p3} & .. &   1   &  
       \end{pmatrix}\]

$$Y_{j,k}=\frac{S_{j,k}}{S_jS_k}=\frac{\Sigma^{n}_{i=1}(x_{i,j}-\bar{x}_j)(x_{i,k}-\bar{x}_k)}{\sqrt{\Sigma^n_{i=1}{(x_{i,j}-\bar{x}_j)^2}}\sqrt{\Sigma^n_{i=1}(x_{i,k}-\bar{x}_k)^2}}$$
$Y_{j,k}=$ koefisien korelasi $x_j$ dan $x_k$

Berikut ini adalah implementasi R:

```{r, echo=T, results='hide'}
cov(Quan)                                           # menerapkan fungsi `cov()`
cor(Quan)                                           # menerapkan fungsi `corr()`
```

## ADE dengan cara Lazy-way

Jalankan semua fungsi di posting ini satu kali dengan fungsi berikut:
```{r, eval=FALSE, message=FALSE}
library(funModeling) 
library(tidyverse) 
library(Hmisc)
library(skimr)
basic_eda <- function(data)
{
  glimpse(data)
  skim(data)
  df_status(data)
  freq(data) 
  profiling_num(data)
  plot_num(data)
  describe(data)
}
basic_eda(df)
```

### Fungsi Glimpse

Fungsi sekilas dari package `dplyr`. Ini akan menampilkan pratinjau vertikal dari dataset. Ini memungkinkan kita untuk melihat jenis data dan sampel data dengan mudah.

### Fungsi Skim

Fungsi `skim` dari package `skimr`. Fungsi skim adalah tambahan yang baik untuk fungsi ringkasan. Ini menampilkan sebagian besar atribut numerik dari ringkasan, tetapi juga menampilkan data yang hilang, lebih banyak informasi kuantil, dan histogram sebaris untuk setiap variabel!

### Fungsi Lain
Gunakan kode berikut untuk mengetahui lebih lanjut tentang fungsi:

```{r, eval=F}
?df_status
?freq
?profiling_num
?plot_num
?describe
```

## Laporan ADE

Dan akhirnya pièce de résistance, daya tarik utama dan alasan saya menulis blog ini; fungsi `create_report` dalam package `DataExplorer`. Fungsi satu baris yang menarik mengagumkan ini akan menarik profil data lengkap dari data frame Anda. Ini akan menghasilkan file HTML dengan statistik dasar, struktur, data yang hilang, visualisasi distribusi, matriks korelasi, dan analisis komponen utama dari data frame Anda! Saya baru-baru ini mengetahui tentang fungsi ini dalam sebuah [workshop yang diberikan oleh Stephe Locke](https://www.eventbrite.com/e/modern-r-for-data-science-workshop-w-steph-locke-tickets-50536282381#) yang dipandu oleh [R Ladies Austin](https://www.meetup.com/rladies-austin/). Fungsi ini berdampak besar!

```{r, eval=FALSE}
library(DataExplorer)
DataExplorer::create_report(df)
```

<!--chapter:end:06-Eksplorasi-Data-Analisis.Rmd-->

# Visualisasi Data {#Visualisasi-Data}
***

Visualisasi data adalah teknik mengambil informasi dari data ke dalam konteks visual, seperti bagan, grafik, dan peta. Visualisasi data membuat data yang besar dan kecil menjadi lebih mudah dimengerti oleh otak manusia, dan visualisasi juga membuat kumpulan data menjadi lebih dapat diandalkan untuk mendeteksi pola, tren, dan pencilan (outliers).

R adalah platform yang luar biasa untuk menganalisis data, mampu membuat hampir semua jenis grafik. Buku ini membantu Anda untuk membuat visualisasi yang paling populer - dari plot cepat dan tidak beraturan hingga grafik yang siap dipublikasikan. Di sini kita akan belajar bagaimana memvisualisasikan data dari poin-poin berikut:

## Data Univariat

Plot univariat biasanya digunakan untuk melakukan distribusi data dari satu variabel. Variabelnya dapat berupa kategorikal`(misalnya, jenis kelamin, ras, negara, kota, dll)` atau kuantitatif `(misalnya, umur, berat, inflasi, nilai, dll)`.

### Kategorikal

Distribusi variabel kategorikal tunggal biasanya diplot dengan diagram batang, diagram lingkaran, atau (lebih jarang) peta pohon.

#### Diagram Batang {-}

Berikut ini adalah contoh yang menunjukkan frekuensi dari dataset [`Marriage`](https://raw.githubusercontent.com/Bakti-Siregar/dataset/master/Bookdown-Data-Science-for-Beginners/Marriage.csv), Saya mendapatkannya dari package [`mosaicData`](https://www.rdocumentation.org/packages/mosaic/versions/1.7.0). Kita gunakan diagram batang untuk menampilkan distribusi peserta pernikahan berdasarkan `Zodiak`.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
#setwd("C:/Users/Bakti/Desktop/")                    # jangan lupa mengatur working directory
Marriage<- read.csv("Data/Marriage.csv")             # memauat data dari PC Anda`
ggplot(Marriage, aes(x = zodiacs)) +                 # memplot distribusi dari `Zodiacs` 
  geom_bar(fill = "cornflowerblue", 
           color= "azure4") +                        # Anda dapat mengganti warna 
  theme_minimal() +                                  # menggunakan tema minimal
  labs(x = "Zodiacs",                                # Anda dapat mengganti label dan judul plot
       y = "Frequency", 
       title = "Marriage Participants by Zodiacs")         
```

Batang pada diagram batang dapat menggambarkan persentase dari jumlah. Untuk diagram batang (zodiak), kode `aes(x=sign)` biasanya merupakan jalan pintas untuk `aes(x = sign, y = ..count..)`, di mana ..count.. adalah variabel khusus yang menggambarkan frekuensi dari setiap kategori. Anda dapat menggunakan ini untuk menghitung persentase, dengan menentukan variabel y secara eksplisit.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
ggplot(Marriage, 
   aes(x = zodiacs, 
       y = ..count.. / sum(..count..))) + 
  geom_bar(fill = rainbow(12), color= "azure4") +
  theme_minimal() +                                  # menggunakan tema minimal
  labs(x = "Zodiacs", 
       y = "Percent", 
  title  = "Marriage Participants in Percent") +
  scale_y_continuous(labels = scales::percent)       # menambahkan simbol % untuk label sumbu y  
```

**Catatan:** Dalam R, warna dapat ditentukan dengan nama (misalnya `col= "red"`) atau dengan triplet RGB heksadesimal (seperti `col = "#FFCC00"`). Anda juga dapat menggunakan sistem warna lain seperti salah satunya diambil dari package `RColorBrewer`.[Lebih lanjut](http://www.sthda.com/english/wiki/colors-in-r)

Mengurutkan batang berdasarkan frekuensi sering kali membantu. Pada kode di bawah ini, frekuensi dihitung secara eksplisit. Kemudian fungsi `reorder` digunakan untuk mengurutkan kategori berdasarkan frekuensinya. Opsi `stat="identity"` memberitahu fungsi plot untuk tidak menghitung jumlah, karena mereka diberikan secara langsung.

```{r, echo=T, results='hide'}
library(dplyr)                                       # untuk manipulasi data
library(ggplot2)                                     # untuk visualisasi
plotdata <- Marriage %>%                             # memuat dataset
 count(zodiacs)                                      # jumlah peserta di setiap 'zodiacs'
# menyusun plot batang secara meningkat
ggplot(plotdata,                                     
       aes(x = reorder(zodiacs, n), 
           y = n)) + 
  geom_bar(stat = "identity",
           fill = rainbow(12), 
           color= "azure4") +
   theme_minimal() +                                  # menggunakan tema minimal
  labs(x = "Zodiacs", 
       y = "Frequency", 
  title  = "Sorting Categories")
```

Jika Anda mungkin ingin memberi label untuk setiap batang dengan nilai numeriknya, ikuti kode berikut:

```{r, echo=T, results='hide'}
library(dplyr)                                       # untuk manipulasi data
library(ggplot2)                                     # untuk visualisasi
library(scales)                                      # menentukan jeda atau label secara otomatis 
plotdata <- Marriage %>%
  count(zodiacs) %>%
  mutate(pct = n / sum(n),
         pctlabel = paste0(round(pct*100), "%"))
# plot batang sebagai persentase, dalam urutan menurun dengan label batang
ggplot(plotdata, 
       aes(x = reorder(zodiacs, -pct),
           y = pct)) + 
  geom_bar(stat = "identity", 
           fill = rainbow(12), 
          color = "azure4") +
  geom_text(aes(label = pctlabel), 
            vjust = -0.25) +
  theme_minimal() +                                  # menggunakan tema minimal
  scale_y_continuous(labels = percent) +
  labs(x = "Zodiacs", 
       y = "Percent", 
       title  = "Labeling Bars")
```

Terkadang label kategori mungkin tumpang tindih, ini sangat mengganggu buka? Jadi, Anda dapat memutar label sumbu.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
library(scales)                                      # menentukan jeda atau label secara otomatis
# memplot batang sebagai persentase, dalam urutan menurun dengan label batang
ggplot(plotdata, 
       aes(x = reorder(zodiacs, -pct),
           y = pct)) + 
  geom_bar(stat = "identity", 
           fill = rainbow(12), 
           color = "azure4") +
  geom_text(aes(label = pctlabel), 
            vjust = -0.25) +
  scale_y_continuous(labels = percent) +
  theme_minimal() +                                  # menggunakan tema minimal
  labs(x = "Zodiacs", 
       y = "Percent", 
       title  = "Overlapping Labels")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Cara lainnya, Anda dapat menangani situasi ini dengan membalik sumbu `x` dan `y`.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
library(scales)                                      # menentukan jeda atau label secara otomatis
# memplot batang sebagai persentase, dalam urutan menurun dengan label batang
ggplot(plotdata, 
       aes(x = reorder(zodiacs, -pct),
           y = pct)) + 
  geom_bar(stat = "identity", 
           fill = rainbow(12), 
           color = "azure4") +
  geom_text(aes(label = pctlabel), 
            hjust = -0.10) +
  scale_y_continuous(labels = percent) +
  theme_minimal() +                                  # menggunakan tema minimal
  labs(x = "Zodiacs", 
       y = "Percent", 
       title  = "Overlapping Labels")+
  coord_flip()
```

#### Diagram Pai {-}

Diagram pai bersifat kontroversial di statistik. Jika tujuan Anda adalah membandingkan frekuensi dari kategori, lebih baik Anda menggunakan diagram batang (orang-orang lebih baik dalam menilai panjang batang dari pada volume irisan lingkaran). Jika tujuan Anda untuk membandingkan setiap kategori secara keseluruhan (misalnya berapa porsi partisipan yang merupakan Hispanik (orang Spanyol) dibandingkan dengan semua partisipan), dan jumlah kategorinya kecil, maka diagram pai mungkin cocok untuk Anda. Dibutuhkan sedikit lebih banyak kode untuk membuat diagram pai lebih menarik dalam R.

Ini adalah contoh untuk membuat diagram pai sederhana dengan ggplot2:

```{r, echo=T, results='hide'}
library(dplyr)                                       # untuk memanipulasi data 
library(ggplot2)                                     # untuk visualisasi
library(scales)                                      # menentukan jeda atau label secara otomatis 
# Persiapan data
plotdata <- Marriage %>%
  count(race) %>%
  arrange(desc(race)) %>%
  mutate(prop = round(n*100/sum(n), 1),
         lab.ypos = cumsum(prop) - 0.5*prop)
# Membuat diagram pai
mycols <- c("#0073C2FF", "#EFC000FF", "#868686FF", "#CD534CFF")
ggplot(plotdata, aes(x = "", y = prop, fill = race)) +
  geom_bar(width = 1, stat = "identity", color = "white") +
  coord_polar("y", start = 0)+
  geom_text(aes(y = lab.ypos, label = prop), color = "white")+
  scale_fill_manual(values = mycols) +
  theme_void()+
  labs(title = "Marriage Participants by Race")
```

Diagram donat hanyalah diagram pai sederhana dengan lubang di dalamnya. Satu-satunya perbedaan antara kode diagram pai adalah kita menetapkan: `x = 2` dan `xlim = c(0.5, 2.5)` untuk membuat lubang di dalam diagram pai. Selain itu, argumen `width` dalam fungsi `geom_bar()` tidak lagi diperlukan.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
library(scales)                                      # menentukan jeda atau label secara otomatis
# membuat diagram donat
ggplot(plotdata, aes(x = 2, y = prop, fill = race)) +
  geom_bar(stat = "identity", color = "white") +
  coord_polar(theta = "y", start = 0)+
  geom_text(aes(y = lab.ypos, label = prop), color = "white")+
  scale_fill_manual(values = mycols) +
  theme_void()+
  xlim(0.5, 2.5)+
  labs(title = "Marriage Participants by Race")
```

Sekarang mari berkreasi dan menambahkan label, sambil menghapus legend.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
library(scales)                                      # menentukan jeda atau label secara otomatis
# tambahkan label persen
plotdata$percent <- paste0(plotdata$race, "\n",
                         round(plotdata$prop), "%")
# membuat diagram donat dalam persen
ggplot(plotdata, aes(x = 2, y = prop, fill = race)) +
  geom_bar(stat = "identity", color = "white") +
  coord_polar(theta = "y", start = 0)+
  geom_text(aes(y = lab.ypos, label = percent), color = "white")+
  scale_fill_manual(values = mycols) +
  theme_void()+
  xlim(0.5, 2.5)+
  labs(title = "Marriage Participants by Race")
```

#### Peta Pohon {-}

Sebuah alternatif untuk diagram pai adalah peta phon. Tidak seperti diagram pai, peta pohon dapat menangani variabel kategorikal yang memiliki banyak tingkatan.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
library(treemapify)                                  # untuk visualisasi
library(scales)                                      # menentukan jeda atau label secara otomatis
plotdata <- Marriage %>%
  count(officialTitle)
ggplot(plotdata, 
       aes(fill = officialTitle, 
           area = n)) +
  geom_treemap() + 
  labs(title = "Marriage Participants by Officiate")
```

Berikut ini adalah versi yang lebih berguna dengan label.

```{r, echo=T, results='hide'}
ggplot(plotdata, 
       aes(fill = officialTitle, 
           area = n, 
           label = officialTitle)) +
  geom_treemap() + 
  geom_treemap_text(colour = "white", 
                    place = "centre") +
  labs(title = "Marriage Participants by Officiate") +
  theme(legend.position = "none")
```

### Kontinu

Distribusi variabel kuantitatif tunggal biasanya diplot dengan histogram, plot [densitas kernel](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Visualization.html), atau plot titik.

#### Histogram {-}

Menggunakan dataset Marriage, mari kita plot usia dari peserta pernikahan.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualiSaSi
ggplot(Marriage, aes(x = age)) +
  geom_histogram(fill = "cornflowerblue", 
                 color = "white",bins = 20) + 
  theme_minimal() +                                  # menggunakan tema minimal
  labs(title="Marriage Participants by age (Basic)",
       x = "Age")
```

Sebagian besar peserta tampaknya berusia 20-an tahun dengan kelompok lain berusia 40-an tahun, dan kelompok yang lebih kecil berusia 60-an dan 70-an tahun. Ini akan menjadi distribusi multimodal. Warna histogram dapat diganti menggunakan dua opsi:

* fill - warna isi untuk batang.
* color - warna batas di sekitar batang.

Cara lainnya adalah Anda dapat menggunakan `binwidth`, lebar nampan yang diwakili oleh batang.

```{r, eval=FALSE}
library(ggplot2)                                     # untuk visualisaSi
library(scales)                                      # menentukan jeda atau label secara otomatis
ggplot(Marriage, 
       aes(x = age, 
           y= ..count.. / sum(..count..))) +
  geom_histogram(fill = "cornflowerblue", 
                 color = "white", 
                 binwidth = 5) +
  theme_minimal() +                                  # menggunakan tema minimal
  labs(title="Marriage Participants by age (Alternative Bins and bandwidths)", 
       y = "Percent",
       x = "Age") +
  scale_y_continuous(labels = percent)
```

Seperti diagram batang, sumbu y dapat mewakili jumlah atau persen dari total.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
library(scales)                                      # menentukan jeda atau label secara otomatis
ggplot(Marriage, 
       aes(x = age, 
           y= ..count.. / sum(..count..))) +
  geom_histogram(fill = "cornflowerblue", 
                 color = "white", 
                 binwidth = 5) +
  theme_minimal() +                                  # menggunakan tema minimal
  labs(title="Marriage Participants by age (Percent)", 
       y = "Percent",
       x = "Age") +
  scale_y_continuous(labels = percent)
```

#### Plot Densitas Kernel {-}

Alternatif untuk histogram adalah plot densitas Kernel. Secara teknis, perkiraan densitas kernel adalah metode non-parametrik untuk memperkirakan fungsi densitas probabilitas dari variabel acak kontinu. (Apa??) Pada dasarnya, kita mencoba untuk menggambar histogram yang diperhalus, di mana area di bawah kurva sama dengan satu.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisaSi
ggplot(Marriage, aes(x = age)) +
  geom_density(fill = "indianred3") +
  theme_minimal() +                                  # menggunakan tema minimal
  labs(title = "Marriage Participants by age")
```

Grafik menunjukkan distribusi dari nilai. Sebagai contoh, perbandingan kasus antara 20 dan 40 tahun akan diwakili oleh area di bawah kurva antara 20 dan 40 pada sumbu x. Seperti diagram sebelumnya, kita juga dapat menggunakan `fill` dan `color` untuk menentukan warna isian dan batasannya.

#### Parameter Penghalusan (Smoothing) {-}

Tingkat kehalusan dikontrol oleh parameter bandwidth `bw`. Untuk menemukan nilai default untuk variabel tertentu, gunakan fungsi `bw.nrd0`. Nilai yang lebih besar akan menghasilkan penghalusan yang lebih banyak, sedangkan nilai yang lebih kecil akan menghasilkan penghalusan yang lebih sedikit.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisaSi
bw.nrd0(Marriage$age)                                # default bandwidth untuk variabel usia

ggplot(Marriage, aes(x = age)) +
  geom_density(fill = "deepskyblue", 
               bw = 1) +
  theme_minimal() +                                  # menggunakan tema manual
  labs(title = "Participants by age",
       subtitle = "bandwidth = 1")
```

Plot densitas kernel memungkinkan Anda dengan mudah melihat skor mana yang paling sering dan mana yang relatif jarang. Namun sulit untuk menjelaskan arti sumbu y kepada seorang non-ahli statistik. (Tapi itu akan membuatmu terlihat sangat pintar!)

#### Diagram Titik {-}

Alternatif lain untuk histogram adalah diagram titik. Sekali lagi, variabel kuantitatif dibagi menjadi beberapa kelompok, tetapi bukan berbentuk batang, setiap pengamatan ditentukan oleh sebuah titik. Secara default, lebar dari sebuah titik sama dengan lebar bin, dan titik-titik bertumpuk, dengan setiap titik mewakili satu pengamatan. Ini bekerja dengan baik jika jumlah pengamatan kecil (katakanlah, kurang dari 150). Opsi `fill` dan `color` dapat digunakan untuk menentukan warna isian dan batasan masing-masing titik.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualiSasi
ggplot(Marriage, aes(x = age)) +
  geom_dotplot(fill = "gold", 
               color = "azure4",
               binwidth = 2) +
  theme_minimal() +                                  # menggunakan tema minimal
  labs(title = "Participants by age",
       y = "Proportion",
       x = "Age")
```

Ada lebih banyak pilihan yang tersedia. [Klik di sini](http://ggplot2.tidyverse.org/reference/geom_dotplot.html) untuk detail dan contoh.

## Data Bivariat

Grafik bivariat menunjukkan hubungan antara dua variabel. Jenis grafik akan tergantung pada tingkat pengukuran dari variabel (kategorikan atau kuantitatif).

### Kategorikal vs. Kategorikal

#### Diagram Batang Bertumpuk {-}

Mari kita plot hubungan antara kelas mobil dan jenis penggerak (roda depan, roda belakang, atau penggerak 4 roda) untuk mobil dalam [dataset Fuel economy](https://bookdown.org/BaktiSiregar/data-science-for-beginners/datasets.html#fuel-economy-data).

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
mpg$drv<-factor(mpg$drv, 
                levels = c("f", "r", "4"),
                labels = c("front-wheel", "rear-wheel", "4-wheel"))
# diagram batang bertumpuk
ggplot(mpg, 
       aes(x = class, 
           fill = drv)) + 
  geom_bar(position = "fill") +
  theme_minimal() +                                  # menggunakan tema minimal
  labs(y = "Proportion")
```

#### Diagram Batang yang Dikelompokkan {-}

Tempat diagram batang yang dikelompokkan untuk variabel kategori kedua secara berdampingan. Untuk membuat plot batang yang dikelompokkan, gunakan opsi `position = "single"`. Perhatikan bahwa opsi ini hanya tersedia di versi pengembangan terbaru ggplot2, tetapi akan segera tersedia secara umum.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
ggplot(mpg, aes(x = class, fill = drv)) +
  theme_minimal() +                                  # menggunakan tema minimal
  geom_bar(position = position_dodge(preserve = "single"))
```

#### Diagram Batang Tersegmentasi {-}

Plot batang yang tersegmentasi merupakan plot batang yang bertumpuk di mana setiap batang mewakili 100 persen. Anda dapat membuat diagram batang tersegmentasi menggunakan opsi `position = "filled"`. Jenis plot ini sangat berguna jika tujuannya adalah untuk membandingkan persentasi dari kategori dalam satu variabel di setiap tingkat variabel lain. Sebagai contoh, proporsi mobil dengan penggerak roda depan (front-wheel) meningkat saat Anda memindahkan dari mobil penumpang yang kecil, ke menengah, ke minivan.

```{r, echo=T, results='hide'}
library(dplyr)                                       # untuk manipulasi data 
library(ggplot2)                                     # untuk visualisasi
library(scales)                                      # menentukan jeda atau label secara otomatis
# membuat ringkasan dataset (manipulasi data)
plotdata <- mpg %>%
  group_by(class, drv) %>%
  dplyr::summarize(n = n()) %>%
  mutate(pct = n/sum(n),
         lbl = scales::percent(pct))
# membuat diagram batang tersegmentasi
# menambahkan label untuk setiap segmen
ggplot(plotdata, 
       aes(x = factor(class),
           y = pct,
        fill = factor(drv))) +
  geom_bar(stat = "identity",
           position = "fill") +
  scale_y_continuous(breaks = seq(0, 1, .2), 
                     label = percent)+
  geom_text(aes(label = lbl),
            size = 3,
            position = position_stack(vjust = 0.5)) +
  scale_fill_brewer(palette = "Set2") +
  theme_minimal() +                                  # menggunakan tema minimal
  labs(y = "Percent",
       fill = "Drive Train",
       x = "Class",
       title = "Automobile Drive by Class") +
  theme_minimal()
```

**Catatan**: Anda dapat menggunakan opsi tambahan untuk meningkatkat warna dan pelabelan. Dalam grafik di bawah ini:

* `factor` mengubah urutan dari kategori untuk variabel kelas dan urutan serta `labels` untuk variabel drive.
* `scale_y_continuous` mengubah label tanda centang sumbu y.
* `labs` menyediakan judul dan mengubah label untuk sumbu x dan y dan juga legend.
* `scale_fill_brewer` mengubah skema warna isian.
* `theme_minimal` menghapus latar belakang abu-abu dan mengubah warna kisi.

Fungsi lainnya dibahas lebih lengkap pada Bab Visualisasi Data Lanjutan.

#### Plot Mosaik {-}

Diagram mosaik dapat menampilkan hubungan antara variabel kategorikal menggunakan persegi panjang yang luasnya mewakili proporsi kejadian untuk kombinasi level tertentu. Warna ubin juga dapat menunjukkan tingkat hubungan antar variabel.

Meskipun plot mosaik dapat dibuat dengan ggplot2 menggunakan package [`ggmosaic`](https://cran.r-project.org/web/packages/ggmosaic/vignettes/ggmosaic.html), saya merekomendasikan menggunakan package `vcd` sebagai gantinya. Meskipun tidak akan membuat grafik ggplot2, package tersebut memberikan pendekatan yang lebih komprehensif untuk memvisualisasikan data kategorikal. 

Orang-orang terpesona dengan Titanic (atau terpesona dengan Leo?). Dalam bencana [Titanic](https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/Titanic.html), peran apa yang dimainkan oleh sex dan class dalam survival? Kita dapat memvisualisasikan hubungan antara ketiga variabel kategorikal menggunakan kode berikut.

```{r, echo=T, results='hide'}
# membuat tabel
tbl <- xtabs(Freq ~ Survived + Class + Sex, Titanic)
ftable(tbl)

# membuat plot mosaik dari tabel
library(vcd)
mosaic(tbl, main = "Titanic data")
```

Ukuran ubin sebanding dengan persentase kasus dalam kombinasi tingkat tersebut. Jelas lebih banyak penumpang yang tewas daripada yang selamat. Mereka yang tewas adalah penumpang laki-laki kelas 3 dan kru laki-laki (kelompok yang terbesar).

Jika kita mengasumsikan bahwa ketiga variabel ini tidak bergantung, kita dapat memeriksa residual dari model dan memberi bayangan pada ubin agar sesuai. Pada grafik di bawah, biru gelap mewakilkan lebih banyak kasus dari yang diharapkan tidak terikat. Merah tua mewakili lebih sedikit kasus dari yang diharapkan jika berlaku tidak terikat.

```{r, echo=T, results='hide'}
mosaic(tbl, 
       shade = TRUE,
       legend = TRUE,
       labeling_args = list(set_varnames = c(Sex = "Gender",
                                             Survived = "Survived",
                                             Class = "Passenger Class")),
       set_labels = list(Survived = c("No", "Yes"),
                         Class = c("1st", "2nd", "3rd", "Crew"),
                         Sex = c("F", "M")),
       main = "Titanic data")
```

Kita dapat melihat jika class, gender, dan survival adalah tidak terikat, kita melihat lebih banyak kru laki-laki yang tewas, dan peremupan kelas 1, 2, dan 3 bertahan hidup daripada yang diharapkan. Sebaliknya, jauh lebih sedikit penumpang kelas 1 (laki-laki dan perempuan) yang meniggal daripada yang diperkirakan secara kebetulan. Dengan demikian asumsi tidak terikat ditolak.

### Kontinu vs. Kontinu

Hubungan antara dua variabel kuantitatif biasanya ditampilkan menggunakan plot sebaran dan grafik garis.

#### Plot Sebaran {-}

Plot Sebaran dibuat untuk mempelajari hubungan antara 2 variabel. Sehingga sering disertai dengan perhitungan koefisien korelasi, yang biasanya mencoba untuk mengukur hubungan linear. Namun jenis hubungan lain dapat dideteksi menggunakan plot sebaran, dan tugas umum terdiri dari menyesuaikan model yang menjelaskan Y dalam fungsi X. Berikut adalah beberapa pola yang dapat Anda deteksi dengan melakukan plot sebaran.

```{r, echo=T, results='hide'}
library(ggplot2)                                   # visualisasi data
library(hrbrthemes)                                # untuk tema `theme_ipsum()` dan legend

# Membuat data
d1 <- data.frame(x=seq(1,100), 
                 y=rnorm(100), 
                 name="No trend")
d2 <- d1 %>% 
mutate(y=x*10 + rnorm(100,sd=60)) %>%
mutate(name="Linear relationship")
d3 <- d1 %>%
mutate(y=x^2 + rnorm(100,sd=140)) %>%
mutate(name="Square")
d4 <- data.frame( x=seq(1,10,0.1), 
                  y=sin(seq(1,10,0.1)) + 
                    rnorm(91,sd=0.6)) %>% 
mutate(name="Sin")
don <- do.call(rbind, list(d1, d2, d3, d4))

# Plot
don %>%
  ggplot(aes(x=x, y=y)) +
    geom_point(color="#69b3a2", alpha=0.8) +
    theme_ipsum() +
    facet_wrap(~name, scale="free")
```

Tampilan yang paling sederhana dari 2 variabel kuantitatif adalah plot sebaran, dengan setiap variabel diwakilkan oleh sumbu. Contohnya, menggunakan dataset `Salaries`, kita dapat memplot pengalaman (`yrs.since.phd`) vs. gaji akademik (`salary`) dari [Profesor perguruan tinggi](https://bookdown.org/BaktiSiregar/data-science-for-beginners/datasets.html#academic-salaries).

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
library(scales)                                      # menentukan jeda atau label secara otomatis
data(Salaries, package="carData")
# plot sebaran yang ditingkatkan
ggplot(Salaries, 
       aes(x = yrs.since.phd, 
           y = salary)) +
  geom_point(color="cornflowerblue", 
             size = 2, 
             alpha=.8) +
  scale_y_continuous(label = scales::dollar, 
                     limits = c(50000, 250000)) +
  scale_x_continuous(breaks = seq(0, 60, 10), 
                     limits=c(0, 60)) +
  theme_minimal() +                                  # menggunakan tema minimal
  labs(x = "Years Since PhD",
       y = "",
       title = "Experience vs. Salary",
       subtitle = "9-month salary for 2008-2009")
```

**Catatan:** opsi `geom_point` dapat digunakan untuk mengubah

* `color` - warna titik
* `size` - ukuran titik
* `shape` - bentuk titik
* `alpha` - transparansi titik. Kisaran transparansi dari 0 (transparan) hingga 1 (buram), dan merupakan parameter yang berguna saat beberapa titik mengalami tumpang tindih.

Fungsi `scale_x_continuous` dan `scale_y_continuous` mengontrol penskalaan pada sumbu x dan y. Kita dapat menggunakan opsi dan fungsi ini untuk membuat plot sebaran yang lebih menarik.

#### Plot Sebaran Menyesuaikan Garis {-}

Seringkali berguna untuk meringkas hubungan yang ditampilkan dalam plot sebaran, dengan menggunakan sebuah garis yang menyesuaikan. Banyak jenis garis yang didukung, termasuk linear, polinomial, dan nonparametrik (loess). Secara default, garis-garis ini ditamplikan dengan batas kepercayaan 95%.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
ggplot(Salaries,
       aes(x = yrs.since.phd, 
           y = salary)) +
  geom_point(color= "cornflowerblue") +
  geom_smooth(method = "lm", color = "brown1")+
  theme_minimal() +                                  # menggunakan tema minimal
  labs(x = "Years Since PhD",
       y = "",
       title = "Experience vs. Salary",
       subtitle = "9-month salary for 2008-2009")
```

Jelas bahwa gaji akan meningkat sesuai dengan pengalaman. Namun, tampaknya ada penurunan diujung kanan - profesor dengan pengalaman signifikan, mendapatkan gaji lebih rendah. Garis lurus tidak dapat merangkap efek non-linear ini. Garis dengan lengkungan akan lebih pas di sini.

Garis regresi polinomial memberikan garis pas dengan bentuk
$$\hat{y}=\beta_0+\beta_1x+\beta-2x^2+...+\beta_nx^2$$

Biasanya digunakan garis kuadrat (satu lengkungan), atau kubik (dua lengkungan). Penggunaan polinomial orde tinggi (>3) jarang diperlukan. menerapkan kesesuaian kuadrat ke data set gaji menghasilkan hasil sebagai berikut.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
ggplot(Salaries, 
       aes(x = yrs.since.phd, 
           y = salary)) +
  geom_point(color= "cornflowerblue") +
  geom_smooth(method = "lm", 
              formula = y ~ poly(x, 2), 
              color = "yellow")+
  theme_minimal() +                                  # menggunakan tema minimal
  labs(x = "Years Since PhD",
       y = "",
       title = "Experience vs. Salary",
       subtitle = "9-month salary for 2008-2009")
```

Akhirnya, garis kesesuaian nonparametrik yang diperhalus sering kali dapat memberikan gambaran yang baik tentang hubungan tersebut. Default di ggplot2 adalah garis [loess](https://www.ime.unicamp.br/~dias/loess.pdf) yang berarti penghalusan plot sebaran yang tertimbang secara lokal.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
ggplot(Salaries, 
       aes(x = yrs.since.phd, 
           y = salary)) +
  geom_point(color="cornflowerblue", 
             size = 2, 
             alpha = 1) +
  geom_smooth(size = 1,
              color = "green") +
  scale_y_continuous(label = scales::dollar, 
                     limits = c(50000, 250000)) +
  scale_x_continuous(breaks = seq(0, 60, 10), 
                     limits = c(0, 60)) +
  theme_minimal() +                                  # menggunakan tema minimal
  labs(x = "Years Since PhD",
       y = "",
       title = "Experience vs. Salary",
       subtitle = "9-month salary for 2008-2009") +
  theme_minimal()
```

### Kategorikal vs. Kontinu

Ketika memplot hubungan antara variabel kategorikal dan variabel kuantitatif, tersedia banyak jenis grafik. ini termasuk diagram batang yang menggunakan ringkasan statistik, plot densitas kernel yang dikelompokkan, plot kotak berdampingan, plot biola berdampingan, plot mean/sem, plot garis punggungan, dan plot Cleveland.

#### Diagram Batang (Ringkasan Statistik) {-}

Di bagian sebelumnya, diagram batang digunakan untuk menampilkan jumlah kejadian berdasarkan kategori untuk variabel tunggal atau untuk dua variabel. Anda juga dapat menggunakan diagram batang untuk menampilkan ringkasan statistik lainnya (seperti mean atau median) pada variabel kuantitatif untuk setiap tingkatan dari variabel kategorikal.

Sebagai contoh, grafik berikut ini menampilkan gaji rata-rata untuk sampel profesor universitas berdasarkan jabatan akademik mereka.

```{r, echo=T, results='hide'}
library(dplyr)                                       # untuk manipulasi data
library(ggplot2)                                     # untuk visualisasi
library(scales)                                      # menentukan jeda atau label secara otomatis

data(Salaries, package="carData")

# menghitung gaji rata-rata untuk setiap jabatan
plotdata <- Salaries %>%
  group_by(rank) %>%
  dplyr::summarize(mean_salary = mean(salary))

# plot gaji rata-rata dengan cara yang lebih menarik
mycols <- c("#CD534CFF", "#EFC000FF", "#0073C2FF")
ggplot(plotdata, 
       aes(x = factor(rank,
                      labels = c("Assistant\nProfessor",
                                 "Associate\nProfessor",
                                 "Full\nProfessor")), 
                      y = mean_salary)) +
  geom_bar(stat = "identity", 
           fill = mycols) +
  geom_text(aes(label = dollar(mean_salary)), 
            vjust = -0.25) +
  scale_y_continuous(breaks = seq(0, 130000, 20000), 
                     label = dollar) +
  theme_minimal() +                                  # menggunakan tema minimal
  labs(title = "Mean Salary by Rank", 
       subtitle = "9-month academic salary for 2008-2009",
       x = "",
       y = "")
```

#### Plot Densitas Kernel yang Dikelompokkan {-}

Seseorang dapat membandingkan kelompok pada variabel numerik dengan melapiskan plot [densitas kernel](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Visualization.html) dalam satu grafik. Mari kita plot distribusi gaji berdasarkan jabatan menggunakan plot densitas kernel.

```{r, echo=T, results='hide'}
ggplot(Salaries, 
       aes(x = salary, 
           fill = rank)) +
  geom_density(alpha = 0.4) +
  theme_minimal() +
  labs(title = "Salary distribution by rank")
```

Opsi `alpha` membuat plot densitas menjadi sebagian transparan sehingga kita dapat melihat apa yang terjadi di bagian yang tumpang tindih. Nilai alpha berkisar dari 0 (transparan) hingga 1 (buram). Grafik tersebut menjelaskan bahwa, secara umum, gaji akan meningkat sesuai jabatan. Namun, kisaran gaji untuk full profesor sangat luas.

#### Plot Kotak

Plot Kotak menampilkan persentil ke-25, median, dan persentil ke-75 dari distribusi. Garis kumis (garis vertikal) menangkap sekitar 99% dari distribusi normal, dan pengamatan di luar kisaran ini diplot sebagai titik yang mewakili pencilan (lihat gambar di bawah).

<center>
<img src="D:/Matana University/Data Scientist Handbook/Data-Science-Untuk-Pemula/boxplot (chapter 7).png" style = "width:100%;">
</center>

Plot Kotak berdampingan sangat berguna untuk membandingkan kelompok (yaitu, tingkatan variabel kategori) pada variabel numerik. Mari kita plot distribusi gaji berdasarkan jabatan menggunakan plot kotak. Plot kotak bertakik memberikan metode perkiraan untuk visualisasi apakah kelompok berbeda. Meskipun bukan sebuah tes yang formal, jika takik dari kedua plot kotak tidak rumpang tindih, maka ada bukti kuat (kepercayaan 95%) bahwa median dari kedua kelompok berbeda.

```{r, echo=T, results='hide'}
mycols <- c("#CD534CFF", "#EFC000FF", "#0073C2FF")
ggplot(Salaries, aes(x = rank, 
                     y = salary)) +
  geom_boxplot(notch = TRUE, 
               fill = mycols, 
               alpha = .7) +
  theme_minimal() +
  labs(title = "Salary Distribution by rank")
```

Dalam contoh di atas, ketiga kelompok itu tampak berbeda. Salah satu keuntungan dari plot kotak adalah lebarnya biasanya tidak berarti. Ini memungkinkan Anda untuk membandingkan distribusi dari banyak kelompok dalam satu grafik.

#### Plot Biola {-}

Plot Biola mirip dengan plot [densitas kernel](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Visualization.html) tetapi dicerminkan dan diputar $90^0$. Mari kita plot distribusi gaji berdasarkan jabatan menggunakan plot biola.

```{r, echo=T, results='hide'}
ggplot(Salaries, 
       aes(x = rank, 
           y = salary)) +
  geom_violin(fill = "azure1") +
  geom_boxplot(width = .2, 
               fill = mycols,
               outlier.color = "red",
               outlier.size = 2) + 
  theme_minimal() +
  labs(title = "Salary distribution by rank")
```

#### Plot Garis Punggung {-}

Plot garis punggung (juga disebut plot kegembiraan) menampilkan distribusi variabel kuantitatif untuk beberapa kelompok. Mereka mirip dengan plot [densitas kernel](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Visualization.html) dari segi [(faceting)](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Visualization.html) vertikal, tetapi memakan lebih sedikit ruang. Plot garis punggung dibuat dengan package `ggridges`.

Menggunakan data set [Fuel economy](https://bookdown.org/BaktiSiregar/data-science-for-beginners/datasets.html#fuel-economy-data), mari kita plot mil perjalanan kota per galon menurut kelas mobil.

```{r, echo=T, results='hide'}
library(dplyr)                                       # untuk manipulasi data
library(ggplot2)                                     # untuk visulisasi
library(ggridges)                                    # untuk mengendalikan visualisasi yang tumpang tindih

ggplot(mpg, 
       aes(x = cty, 
           y = class, 
           fill = class)) +
  geom_density_ridges(alpha = 0.7) + 
  theme_ridges() +
  labs("Highway mileage by auto class") +
  theme(legend.position = "none")
```

Saya telah menyembunyikan legend di sini karena itu berlebihan (distribusinya sudah diberi label pada sumbu y). Tidak mengherankan, truk pikap memiliki jarak tempuh yang paling rendah, sementara mobil subkompak dan kompak cenderung mencapai peringkat. Namun, ada rentang skor jarak tempuh yang sangat luas untuk mobil-mobil kecil ini.

Perhatikan kemungkinan tumpang tindih distribusi adalah diputuskan lebih kepada grafik mobil kompak. Anda dapat menambahkan transparansi jika tumpang tindihnya parah, dengan menggunakan `geom_density_ridges(alpha = n)`, dimana n berkisar dari 0 (transparan) hingga 1 (buram). Lihat [package vignette](https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html) untuk lebih jelasnya.

#### Plot Garis {-}

Metode populer untuk membandingkan kelompok pada variabel numerik adalah plot rata-rata dengan batang kesalahan. Batang kesalahan dapat mewakilkan deviasi standar, kesalahan standar dari rata-rata, atau interval kepercayaan. Pada bagian ini, kita akan plot rata-rata dan kesalahan standar. Kita dapat menggunakan teknik yang sama untuk membandingkan gaji terhadap jabatan dan jenis kelamin. (Secara teknis, ini bukan bivariat karena kita memplot jabatan, jenis kelamin, dan gaji, tetapi itu terlihat cocok di sini).

```{r, echo=T, results='hide'}
library(dplyr)                                       # untuk manipulasi data
library(ggplot2)                                     # untuk visualisasi
library(ggridges)                                    # untuk menangani visualisasi yang tumpang tindih
# menghitung rata-rata, deviasi standar,
# kesalahan standar, dan 95% interval kepercayaan 
# berdasarkan jabatan
plotdata <- Salaries %>%
  group_by(rank, sex) %>%
  dplyr::summarize(n = n(),
            mean = mean(salary),
            sd = sd(salary),
            se = sd/sqrt(n),
            ci = qt(0.975, df = n - 1) * sd / sqrt(n))
# meningkatkan plot rata-rata kesalahan atau standar kesalahan
pd <- position_dodge(0.2)
ggplot(plotdata, 
       aes(x = factor(rank, 
                      labels = c("Assistant\nProfessor",
                                 "Associate\nProfessor",
                                 "Full\nProfessor")), 
           y = mean, 
           group=sex, 
           color=sex)) +
  geom_point(position=pd, 
             size = 3) +
  geom_line(position = pd, 
            size = 1) +
  geom_errorbar(aes(ymin = mean - se, 
                    ymax = mean + se), 
                width = .1, 
                position = pd, 
                size = 1) +
  scale_y_continuous(label = scales::dollar) +
  scale_color_brewer(palette="Set1") +
  theme_minimal() +
  labs(title = "Mean salary by rank and sex",
       subtitle = "(mean +/- standard error)",
       x = "", 
       y = "",
       color = "Gender")
```

#### Plot Strip {-}

Hubungan antara variabel pengelompokan dan variabel numerik dapat ditampilkan dengan plot sebaran. Contoh, plot distribusi gaji berdasarkan jabatan menggunakan plot strip. Plot sebar satu dimensi ini disebut sebagai plot strip. Sayangnya, pencetakan titik yang berlebihan membuat interpretasinya menjadi sulit. Hubungannya lebih mudah dilihat jika titik-titiknya goyah. Pada dasarnya bilangan kecil acak ditambahkan ke setiap koordinat y. Akan lebih memudahkan untuk membandingkan kelompok jika kita menggunakan warna.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visulisasi
library(scales)                                      # penskalaan infrastruktur
ggplot(Salaries, 
       aes(y = factor(rank,
                      labels = c("Assistant\nProfessor",
                                 "Associate\nProfessor",
                                 "Full\nProfessor")), 
           x = salary, 
           color = rank)) +
  geom_jitter(alpha = 0.7,
              size = 1.5) + 
  scale_x_continuous(label = dollar) +
  labs(title = "Academic Salary by Rank", 
       subtitle = "9-month salary for 2008-2009",
       x = "",
       y = "") +
  theme_minimal() +
  theme(legend.position = "none")
```

Opsi `legend.position = "none"` digunakan untuk menyembunyikan legend (yang tidak diperlukan di sini). Plot jitter bekerja dengan baik ketika jumlah dari titik-titik tidak terlalu besar.

#### Menggabungkan Jitter dan Plot Kotak {-}

Mungkin lebih mudah untuk memvisualisasikan distribusi jika kita menambahkan plot kotak ke plot jitter. Beberapa pilihan ditambahkan untuk membuat plot ini.

* Untukplot kotak:
  * `size = 1` membuat garis menjadi lebih tebal
  * `outlier.color = "black"` membuat pencilan berwarna hitam
  * `outlier.shape = 1` menentukan lingkaran untuk pencilan
  * `outlier.size = 3` meningkatkan ukuran dari pencilan

* Untik jitter:
  * `alpha = 0.5` membuat titik-titik menjadi lebih transparan
  * `width = .2` mengurangi jumlah jitter (.4 adalah default)

Akhirnya, sumbu x dan y dibalik menggunakan fungsi `coord_flip` (yaitu, grafik diputar pada sisinya).

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visulisasi
library(scales)                                      # penskalaan infrastruktur
ggplot(Salaries, 
       aes(x = factor(rank,
                      labels = c("Assistant\nProfessor",
                                 "Associate\nProfessor",
                                 "Full\nProfessor")), 
           y = salary, 
           color = rank)) +
  geom_boxplot(size=1,
               outlier.shape = 1,
               outlier.color = "black",
               outlier.size  = 3) +
  geom_jitter(alpha = 0.5, 
              width=.2) + 
  scale_y_continuous(label = dollar) +
  labs(title = "Academic Salary by Rank", 
       subtitle = "9-month salary for 2008-2009",
       x = "",
       y = "") +
  theme_minimal() +
  theme(legend.position = "none") +
  coord_flip()
```

Sebelum melanjutkan, ada baiknya untuk memerhatikan fungsi [`geom_boxjitter`](https://www.rdocumentation.org/packages/ggpol/versions/0.0.1/topics/geom_boxjitter) yang disediakan dalam package [`ggpol`](https://erocoar.github.io/ggpol/). Ini membuat plot kotak hibrida - setengah plot kotak, setengan plot sebaran.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visulisasi
library(scales)                                      # penskalaan infrastruktur
library(ggpol)                                       # plot kotak hibrida - setengah plot sebaran
ggplot(Salaries, 
       aes(x = factor(rank,
                      labels = c("Assistant\nProfessor",
                                 "Associate\nProfessor",
                                 "Full\nProfessor")), 
           y = salary, 
           fill=rank)) +
  geom_boxjitter(color="black",
                 jitter.color = "darkgrey",
                 errorbar.draw = TRUE) +
  scale_y_continuous(label = dollar) +
  labs(title = "Academic Salary by Rank", 
       subtitle = "9-month salary for 2008-2009",
       x = "",
       y = "") +
  theme_minimal() +
  theme(legend.position = "none")
```

#### Plot Kawanan Lebah {-}

Plot kawanan lebah (juga disebut plot sebaran biola) mirip dengan plot sebaran jitter, di mana plot tersebut menampilkan distribusi dari variabel kuantitatif dengan memplot titik-titik dengan cara mengurangi tumpang tindih. Selain itu, mereka juga membantu menampilkan densitas dari data di setiap titik (dengan cara yang mirip dengan [plot biola](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Visualization.html)). Melanjutkan contoh sebelumnya.

```{r, echo=T, results='hide'}
library(ggplot2)                                     # untuk visualisasi
library(scales)                                      # penskalaan infrastruktur
library(ggbeeswarm)                                  # mengurangi tumpang tindih
ggplot(Salaries, 
       aes(x = factor(rank,
                      labels = c("Assistant\nProfessor",
                                 "Associate\nProfessor",
                                 "Full\nProfessor")), 
           y = salary, 
           color = rank)) +
  geom_quasirandom(alpha = 0.7,
                   size = 1.5) + 
  scale_y_continuous(label = dollar) +
  labs(title = "Academic Salary by Rank", 
       subtitle = "9-month salary for 2008-2009",
       x = "",
       y = "") +
  theme_minimal() +
  theme(legend.position = "none")
```

Plot dibuat menggunakan fungsi `geom_quasirandom`. Plot ini dapat lebih mudah dibaca daripada plot strip jitter sederhana. Untuk mempelajari lebih lanjut mengenai plot ini, lihat [Plot bergaya kawanan lebah](https://github.com/eclarke/ggbeeswarm) dengan ggplot2.

#### Diagram Titik Cleveland {-}

Plot Cleveland berguna ketika Anda ingin membandingkan statistik numerik untuk sejumlah besar kelompok. Misalnya, Anda ingin membandingkan harapan hidup tahun 2007 untuk negara Asia menggunakan data set [`gapminder`](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Visualization.html).

```{r, echo=T, results='hide'}
library(dplyr)                                       # untuk manipulasi data
library(ggplot2)                                     # untuk visualisasi
library(scales)                                      # penskalaan infrastruktur
library(ggbeeswarm)                                  # mengurangi tumpang tindih
library(gapminder)                                   # untuk dataset `gapminder` 
data(gapminder, package="gapminder")                 # memuat dataset `gapminder` 
# subset negara-negara Asian tahun 2007
library(dplyr)
plotdata <- gapminder %>%
  filter(continent == "Asia" & 
         year == 2007)
# Plot Cleveland yang menarik
ggplot(plotdata, 
       aes(x=lifeExp, 
           y=reorder(country, lifeExp))) +
  geom_point(color="blue", 
             size = 2) +
  geom_segment(aes(x = 40, 
               xend = lifeExp, 
               y = reorder(country, lifeExp), 
               yend = reorder(country, lifeExp)),
               color = "azure3") +
  labs (x = "Life Expectancy (years)",
        y = "",
        title = "Life Expectancy by Country",
        subtitle = "GapMinder data for Asia - 2007") +
  theme_minimal() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
```

Jepang jelas memiliki angka harapan hidup yang paling tinggi, sedangkan Afghanistan sejauh ini yang paling rendah. Plot terakhir ini disebut juga dengan grafik lolipop.

## Data Multivariat

Grafik Multivariat menampilkan hubungan antara tiga variabel atau lebih. Ada dua metode umum untuk menampung variabel: pengelompokan dan faceting.

### Pengelompokan

Dalam pengelompokan, nilai dari dua variabel pertama dipetakan ke sumbu x dan y. Kemudian variabel tambahan dipetakan ke karakteristik visual lainnya seperti warna, bentuk, ukuran, jenis garis, dan transparansi. Pengelompokan memungkinkan Anda untuk memplot data untuk beberapa grup dalam satu grafik. Dengan menggunakan data set [Salaries](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Visualization.html), mari kita tampilkan hubungan antara `yrs.since.phd` dan `salary`.

```{r, echo=T, results='hide'}
library(carData)                                     # untuk dataset
library(ggplot2)                                     # untuk visualisasi
data(Salaries, package="carData")
ggplot(Salaries, aes(x = yrs.since.phd, 
                     y = salary, 
                     color=rank)) +
  geom_point() +
  theme_minimal() +
  labs(title = "Academic salary by rank and years since degree")
```

Selanjutnya, tambahkan jenis kelamin profesor, menggunakan bentuk titik untuk menunjukkan jenis kelamin. Kita akan meningkatkan ukuran titik dan menambahkan transparansi untuk memperjelas titik individual.

```{r, echo=T, results='hide'}
library(carData)                                     # untuk dataset
library(ggplot2)                                     # untuk visualisaSi
ggplot(Salaries, 
       aes(x = yrs.since.phd, 
           y = salary, 
           color = rank, 
           shape = sex)) +
  geom_point(size = 3, alpha = .6) +
  theme_minimal() +
  labs(title = "Academic salary by rank, sex, and years since degree")
```

Kita tidak dapat mengatakan bahwa ini adalah grafik yang bagus. Ini sangat sibuk, dan mungkin sulit untuk membedakan profesor pria dari wanita. Faceting (dijelaskan di bagian berikutnya) mungkin akan menjadi pendekatan yang lebih baik.

Perhatikan perbedaan antara menentukan nilai konstan (seperti size = 3) dan pemetaan variabel untuk karakteristik visual (contoh, color = rank). Pemetaan selalu ditempatkan di dalam fungsi aes, sedangkan penetapan nilai konstanta selalu muncul di luar fungsi aes.

Berikut adalah contoh yang lebih jelas. Kita akan membuat grafik hubungan antar tahun sejak Ph.D. dan gaji menggunakan ukuran dari titik untuk menunjukkan masa kerja. Ini disebut plot gelembung.

```{r, echo=T, results='hide'}
library(carData)                                     # untuk dataset
library(ggplot2)                                     # untuk visualisasi
ggplot(Salaries, 
       aes(x = yrs.since.phd, 
           y = salary, 
           color = rank, 
           size = yrs.service)) +
  geom_point(alpha = .8) +
  theme_minimal() +
  labs(title = "Academic salary by rank, years of service, and years since degree")
```

Jelas sekali ada hubungan positif yang kuat antara tahun-tahun sejak Ph.D. dan tahun layanan. Asisten Profesor ada dalam jangkauan 0-11 tahun sejak Ph.D. dan 0-10 tahun layanan. Orang-orang profesional yang jelas sangat berpengalaman tidak hanya berada di tingkat Asisten Profesor (mereka mungkin dipromosikan atau keluar dari Universitas). Kita tidak menemukan batasan waktu yang sama antara Associate dan Full Professors. [Plot gelembung](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Visualization.html) dijelaskan lebih mendalam di bab selanjutnya.

Sebagai contoh terakhir, mari kita lihat `yrs.since.phd` vs. `salary` dan tambahkan jenis kelamin menggunakan warna dan [garis kuadrat yang paling cocok](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Visualization.html).

```{r, echo=T, results='hide'}
library(carData)                                     # untuk dataset
library(ggplot2)                                     # untuk visualisasi
ggplot(Salaries, 
       aes(x = yrs.since.phd, 
           y = salary, 
           color = sex)) +
  geom_point(alpha = .4, 
             size = 3) +
  geom_smooth(se=FALSE, 
              method = "lm", 
              formula = y~poly(x,2), 
              size = 1.5) +
  labs(x = "Years Since Ph.D.",
       title = "Academic Salary by Sex and Years Experience",
       subtitle = "9-month salary for 2008-2009",
       y = "",
       color = "Sex") +
  scale_y_continuous(label = scales::dollar) +
  scale_color_brewer(palette = "Set1") +
  theme_minimal()
```

### Pembagian Faset (Faceting)

Pengelompokan memungkinkan Anda untuk memplot beberapa variabel dalam satu grafik, menggunakan karakteristik visual seperti, warna, bentuk, dan ukuran. Dalam pembagian faset, sebuah grafik terdiri dari beberapa plot-plot terpisah atau kelipatan kecil, satu untuk setiap tingkatan dari variabel ketiga, atau kombinasi variabel. Ini akan lebih mudah dipahami dengan sebuah contoh.

```{r, echo=T, results='hide'}
library(carData)                                     # untuk dataset
library(ggplot2)                                     # untuk visualisasi
ggplot(Salaries, aes(x = salary)) +
  geom_histogram(fill = "cornflowerblue",
                 color = "white") +
  facet_wrap(~rank, ncol = 1) +
  theme_minimal() +
  labs(title = "Salary histograms by rank")
```

Fungsi `facet_wrap` membuat grafik terpisah untuk setiap tingkat jabaran. Opsi `ncol` mengatur jumlah kolom. Dalam contoh berikutnya akan menggunakan dua variabel untuk mendefinisikan faset. Di sini, fungsi menetapkan jenis kelamin ke baris dan jabatan ke kolom, membuat matriks enam plot dalam satu grafik.

```{r, echo=T, results='hide'}
library(carData)                                     # untuk dataset
library(ggplot2)                                     # untuk visualisasi
ggplot(Salaries, aes(x = salary / 1000)) +
  geom_histogram(color = "white",
                 fill = "cornflowerblue") +
  facet_grid(sex ~ rank) +
  theme_minimal() +
  labs(title = "Salary histograms by sex and rank",
       x = "Salary ($1000)")
```

Kita juga dapat mengkombinasi pengelompokan dan pembagian faset. Mari kita gunakan Plot Mean/SE dan pembagian faset untuk membandingkan gaji-gaji dari profesor pria dan wanita, dalam jabatan dan disiplin ilmu. Kita akan menggunakan warna untuk membedakan jenis kelamin dan pembagian faset untuk membuat plot-plot jabatan berdasarkan kombinasi disiplin ilmu.

```{r, echo=T, results='hide'}
library(carData)                                     # untuk dataset
library(ggplot2)                                     # untuk visualisasi
library(dplyr)                                       # manipulasi data
# menghitung rata-rata dan kesalahan standar berdasarkan 
# jenis kelamin, jabatan, dan disiplin ilmu
plotdata <- Salaries %>%
  group_by(sex, rank, discipline) %>%
  dplyr::summarize(n = n(),
            mean = mean(salary),
            sd = sd(salary),
            se = sd / sqrt(n))
# membuat label yang lebih baik untuk disiplin ilmu
plotdata$discipline <- factor(plotdata$discipline,
                              labels = c("Theoretical",
                                         "Applied"))
# membuat plot
ggplot(plotdata, 
       aes(x = sex, 
           y = mean,
           color = sex)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = mean - se, 
                    ymax = mean + se),
                width = .1) +
  scale_y_continuous(breaks = seq(70000, 140000, 10000),
                     label = scales::dollar) +
  facet_grid(. ~ rank + discipline) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major.x = element_blank(),
        panel.grid.minor.y = element_blank()) +
  labs(x="", 
       y="", 
       title="Nine month academic salaries by gender, discipline, and rank",
       subtitle = "(Means and standard errors)") +
  scale_color_brewer(palette="Set1")
```

Pernyataan `facet_grid(.~rank+dicipline)` tidak menentukan variabel baris (.) dan kolom yang ditentukan oleh kombinasi jabatan dan disiplin ilmu.

Fungsi `theme()` membuat tema hitam dan putih dan menghilangkan garis grid vertikal dan garis grid horizontal minor. Fungsi `scale_color_brewer()` mengubah skema warna untuk titik dan batang-batang kesalahan.

Pada pandangan pertama, tampaknya mungkin ada perbedaan gender dalam gaji untuk Associate dan Full Professors di bidang teoritis. Saya mengatakan "mungkin" karena kita belum melakukan pengujian hipotesis formal apapun (dalam kasus ini adalah ANCOVA). Lihat bagian [Penyesuaian](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Visualization.html) untuk mempelajari lebih lanjut mengenai penyesuaian tampilan grafik.

Sebagai contoh terakhir, kita akan beralih ke dataset baru dan memplot perubahan dalam harapan hidup dari waktu ke waktu untuk negara-negara di "Asia". Data tersebut berasal dari dataset `gapminder` dalam package `gapminder`. Setiap negara muncul dalam fasetnya sendiri. Fungsi tema digunakan untuk menyederhanakan warna latar belakang, memutar teks sumbu x, dan memperkecil ukuran tulisan.

```{r, echo=T, results='hide'}
library(gapminder)                                   # untuk dataset
library(ggplot2)                                     # untuk visualisasi
library(dplyr)                                       # manipulasi data
# memplot harapan hidup berdasarkan tahun secara terpisah
# untuk setiap negara di Asia
data(gapminder, package = "gapminder")

# Pilih data Asia
plotdata <- dplyr::filter(gapminder, 
                          continent == "Asia")

# memplot harapan hidup berdasarkan tahun, untuk setiap negara
ggplot(plotdata, aes(x=year, y = lifeExp)) +
  geom_line(color="grey") +
  geom_point(color="blue") +
  facet_wrap(~country) + 
  theme_minimal(base_size = 9) +
  theme(axis.text.x = element_text(angle = 45, 
                                   hjust = 1)) +
  labs(title = "Changes in Life Expectancy",
       x = "Year",
       y = "Life Expectancy") 
```

<!--chapter:end:07-Vusialisasi-Data.Rmd-->

# Visualisasi Data Lanjut {#Visualisasi-Data-Lanjut}
***

## Deret Waktu

Deret waktu adalah sekumpulan nilai kuantitatif yang diperoleh pada titik-titik waktu yang berurutan. Interval antara titik-titik waktu (mis., jam, hari, minggu, bulan, atau tahun) biasanya sama.

### Grafik Garis

Grafik bergantung dengan waktu yang paling umum adalah grafik garis deret waktu. Mari kita pertimbangkan [deret waktu Ekonomi AS](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Advanced-Visualizations.html) yang disertakan dengan package ggplot2. Ini berisi data ekonomi bulanan AS yang dikumpulkan dari Januari 1967 hingga Januari 2015. Mari kita plot tingkat menabung pribadi `psavert`. Kita dapat melakukan ini dengan plot garis sederhana.

```{r, echo=T, results='hide'}
library(ggplot2)                                  # visualisasi data 
data(economics, package = "ggplot2")              # memuat data
ggplot(economics, aes(x = date, y = psavert)) +   # menetapkan sumbu x dan y dari dataset
  geom_line(color = "indianred",size=0.6) +       # menambahkan grafik garis, warna dan ukuran
  theme_minimal()+                                # tema untuk tampilan yang lebih baik
  labs(title = "Personal Savings Rate",           # judul untuk grafik
       x = "Date",                                # menamakan kembali sumbu x
       y = "Rate")                                # menamakan kembali sumbu y
```

Fungsi `scale_x_date` dapat digunakan untuk memformat ulang tanggal. Pada grafik berikut, tanda centang muncukl setiap 5 tahun, dan tanggal akan ditampilkan dengan format MMM-YY. Selain itu, garis deret waktu diberi warna off-red dan dibuat lebih tebal, garis tren (loess), dan judul ditambahkan, dan tema disederhanakan.

```{r, echo=T, results='hide'}
library(ggplot2)                                  # visualisasi data
library(scales)                                   # penskalaan dan pemusatan objek seperti matriks
data(economics, package = "ggplot2")              # memuat data
ggplot(economics, aes(x = date, y = psavert)) +   # menetapkan sumbu x dan y dari dataset
  geom_line(color = "indianred", size=0.6) +      # menambahkan grafik garis, warna, dan ukuran
  geom_smooth(formula = y~x, method = 'loess') +  # grafik hubungan antara x dan y
  theme_minimal()+                                # tema untuk tampilan yang lebih baik
  scale_x_date(date_breaks = '5 years',  
               labels = date_format("%b-%y")) +
  labs(title = "Personal Savings Rate",
       subtitle = "1967 to 2015",
       x = "",
       y = "Rate") 
```

**Catatan:** Ketika memplot deret waktu, pastikan bahwa variabel datanya adalah kelas tanggal dan bukan kelas karakter. Lihat [nilai tanggal](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Advanced-Visualizations.html) untuk lebih jelasnya.

Mari tutup bagian ini dengan deret waktu multivariat (lebih dari satu deret). Kita akan membandingkan harga penutupan untuk Appel dan Facebook dari 1 Jan 2019 hingga hari ini.

```{r, echo=T, results='hide'}
library(quantmod)                                 # kerangka pemodelan keuangan kuantitatif
library(dplyr)                                    # manipulasi data
library(ggplot2)                                  # visualisasi data
# mendapatkan harga penutupan Apple (AAPL)
apple <- getSymbols("AAPL",src = "yahoo",
                    return.class = "data.frame", 
                    from="2019-01-01")
# memproses data yang ingin kita analisis
apple <- AAPL %>%                                 
  mutate(Date = as.Date(row.names(.))) %>%
  select(Date, AAPL.Close) %>%
  rename(Close = AAPL.Close) %>%
  mutate(Company = "Apple")
# mendapatkan harga penutuoan facebook (FB)
facebook <- getSymbols("FB", src = "yahoo",
                       return.class = "data.frame", 
                       from="2019-01-01")
# memproses data yang ingin kita analisis 
facebook <- FB %>% 
  mutate(Date = as.Date(row.names(.))) %>%
  select(Date, FB.Close) %>%
  rename(Close = FB.Close) %>%
  mutate(Company = "Facebook")
# menggabungkan data dari kedua perusahaan
mseries <- rbind(apple, facebook)
# memvisualisasikan data
ggplot(mseries, aes(x=Date, y= Close, color=Company)) + 
  geom_line(size=1) +
  scale_x_date(date_breaks = '1 month', 
               labels = scales::date_format("%b-%y")) +
  scale_y_continuous(limits = c(120, 380), 
                     breaks = seq(120, 380, 10),
                     labels = scales::dollar) +
  labs(title = "NASDAQ Closing Prices",
       subtitle = "Jan 2019 until today",
       caption = "source: Yahoo Finance",
       y = "Closing Price") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  scale_color_brewer(palette = "Dark2")
```

### Grafik Area

Grafik area sederhana pada dasarnya adalah grafik garis, dengan isian dari garis menuju sumbu x.

```{r, echo=T, results='hide'}
library(ggplot2)                                  # visualisasi data
data(economics, package = "ggplot2")              # memuat data
ggplot(economics, aes(x = date, y = psavert)) +
  geom_area(fill="azure3", color="indianred3") +
  theme_minimal() +
  labs(title = "Personal Savings Rate",
       x = "Date",
       y = "Personal Savings Rate")
```

Grafik area bertumpuk dapat digunakan untuk menunjukkan perbedaan antara grup dari waktu ke waktu. Pertimbangkan data set `uspopage` dari package `gcookbook`. Kita akan memplot distribusi usia populasi AS antara tahun 1900 dan 2002.

```{r, echo=T, results='hide'}
library(ggplot2)                                  # data visualization
library(gcookbook)                                # data kesehatan dan ekonomi tentang negara-negara
data(uspopage, package = "gcookbook")             # memuat data
ggplot(uspopage, aes(x = Year,
                     y = Thousands, 
                     fill = AgeGroup)) +
  geom_area() +
  theme_minimal()+
  labs(title = "US Population by age",
       x = "Year",
       y = "Population in Thousands")
```

Cara terbaik adalahmenghindari notasi ilmiah pada grafik Anda. Seberapa besar kemungkinan rata-rata pembaca akan mengetahui bahwa 3e+05 artinya 300,000,000? Mudah untuk mengubah skala di ggplot2. Cukup bagi variabel Ribuan dengan 1000 dan laporkan sebagai Jutaan. Sementara kita melakukannya, mari kita

* membuat batasan hitam untuk menyoroti perbedaan antar grup,
* membalik urutan grup agar sesuai dengan bertambahnya usia,
* meningkatkan pelabelan,
* memilih skema warna yang berbeda.

Tingkat variabel `AgeGroup` dapat dibalik menggunakan fungsi `fct_rev` di package `forcats`.

```{r, echo=T, results='hide'}
library(ggplot2)                                  # visualisasi data
library(gcookbook)                                # data kesehatan dan ekonomi tentang negara-negara
data(uspopage, package = "gcookbook")             # memuat data
ggplot(uspopage, aes(x = Year,
                     y = Thousands/1000, 
                     fill = forcats::fct_rev(AgeGroup))) +
  geom_area(color = "black") +
  labs(title = "US Population by age",
       subtitle = "1900 to 2002",
       caption = "source: U.S. Census Bureau, 2003, HS-3",
       x = "Year",
       y = "Population in Millions",
       fill = "Age Group") +
  scale_fill_brewer(palette = "Set2") +
  theme_minimal()
```

**Tantangan Anda:** Lakukan hal yang sama untuk memvisualisasikan data populasi Indonesia menggunakan dataset [`economics`](https://bookdown.org/BaktiSiregar/data-science-for-beginners/datasets.html#economic-timeseries)

### Grafik Barbel

Grafik khusus ini berguna untuk menampilkan perubahan antara dua titik waktu untuk beberapa grup atau pengamatan. Menggunakan fungsi `geom_dumbbell` dari package `ggalt`.

Menggunakan dataset [`gapminder`](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Advanced-Visualizations.html) mari kita plot perubahan harapan hidup di Asia dari tahun 1952 sampai 2007. Dataset dalam format panjang. Kita perlu mengubahnya menjadi format lebar untuk membuat plot barbel. Dalam grafik ini, kita akan mengurutkan berdasarkan harapan hidup tahun 1952, dan memodifikasi ukuran garis dan titik, memberi warna titik, menambahkan judul dan label, dan menyederhanakan tema.

```{r, echo=T, results='hide'}
library(ggalt)                                    # mengandung tambahan geom, skala, dll
library(dplyr)                                    # manipulasi data
library(tidyr)                                    # data berantakan dan rapi
library(ggplot2)                                  # visualisasi data
data(gapminder, package = "gapminder")            # memuat data
# data subset
plotdata_long <- filter(gapminder,
                        continent == "Asia" &
                        year %in% c(1952, 2007)) %>%
  select(country, year, lifeExp)
# mengubah data format lebar
plotdata_wide <- spread(plotdata_long, year, lifeExp)
names(plotdata_wide) <- c("country", "y1952", "y2007")
# membuat plot barbel
ggplot(plotdata_wide, 
       aes(y = reorder(country, y1952),
           x = y1952,
           xend = y2007)) +  
  geom_dumbbell(size_x = 2,
                size = 0.8,
                size_xend = 2,
                colour_x = "aquamarine3", 
                colour = "cornflowerblue", 
                colour_xend = "indianred") +
  theme_minimal() + 
  labs(title = "Change of Life Expectancy in Asia",
       subtitle = "1952 to 2007",
       x = "Life Expectancy (years)",
       y = "")
```

Lebih mudah untuk melihat pola di sini. Misalnya `Afganistan` memulai dengan harapan hidup terendah pada tahun 1952 dan masih terendah pada tahun 2007. `Israel` memulai dengan harapan hidup yang relatif tinggi dengan hanya membuat sedikit kemajuan.

### Grafik Kemiringan

Jika ada beberapa kelompok dan beberapa titik waktu, grafik kemiringan dapat membantu. Mari kita plot harapan hidup dari tujuh negara Asia Tenggara pada tahun 1992, 1997, 2002, dan 2007. Sekali lagi, kita akan menggunakan data [`gapminder`](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Advanced-Visualizations.html).

Untuk membuat grafik kemiringan, kita akan menggunakan fungsi [`newggslopegraph`](https://www.rdocumentation.org/packages/CGPfunctions/versions/0.4/topics/newggslopegraph) dari package `CGPfunctions`. Parameter fungsi `newggslopegraph` adalah (berurutan)

* Data frame,
* Variabel waktu (yang harus sebagai faktor),
* Variabel numerik yang akan diplot,
* Variabel Pengelompokkan (membuat satu garis per kelompok).

```{r, echo=T, results='hide'}
library(ggalt)                                    # mengandung tambahan geom, skala, dll
library(dplyr)                                    # manipulasi data
library(tidyr)                                    # data berantakan dan rapi
library(ggplot2)                                  # visualisasi data
library(CGPfunctions)                             # fungsi lain-lain (grafik kemiringan)
data(gapminder, package = "gapminder")            # memuat data
# Memilih tujuh data negara Asia Tenggara 
# untuk tahun 1992, 1997, 2002, dan 2007
df <- gapminder %>%
  filter(year %in% c(1992, 1997, 2002, 2007) &
           country %in% c("Indonesia", "Singapore", 
                          "Malaysia", "Vietnam",
                          "Philippines","Thailand",
                          "Myanmar")) %>%
  mutate(year = factor(year),
         lifeExp = round(lifeExp)) 
# membuat grafik kemiringan
newggslopegraph(df, year, lifeExp, country) +
  labs(title="Life Expectancy by Country", 
       subtitle="Southeast Asia", 
       caption="source: gapminder")
```

Pada grafik di atas, `Singapore` memiliki harapan hidup tertinggi dalam rentang tahun. `Myanmar` memiliki harapan hidup terendah hingga akhir penelitian.

## Grafik Lain

Grafik-grafik pada bagian ini dapat sangat berguna di kehidupan sehari-hari Anda sebagai seorang data scientist, tetapi ini mungkin tidak terlalu mudah dibandingkan dengan grafik-grafik yang telah Anda pelajari sejauh ini.

### Grafik Gelembung

Plot gelembung adalah plot sebaran yang mana dimensi ketiga ditambahkan: nilai variabel numerik tambahan ditunjukkan melalui ukuran titik. Anda membutuhkan 3 variabel numerik sebagai input: satu diwakili oleh sumbu x, satu oleh sumbu y, dan satu oleh ukuran titik.

Berikut ini adalah contoh yang menggunakan abstrak dataset `gapminder` yang terkenal melalui Hans Rosling Ted Talk. Ini memberikan rata-rata harapan hidup, PDB per kapita, dan ukuran populasi untuk lebih dari 100 negara. Dataset ini tersedia melalui package R yaitu `gapminder`.

```{r, echo=T, results='hide'}
library(gapminder)                                 # dataset
library(tidyverse)                                 # manipulasi data
library(hrbrthemes)                                # untuk `theme_ipsum()` dan legend
library(ggplot2)                                   # visualisasi data
library(gridExtra)                                 # fungsi lain-lain untuk grafik "Kisi"
library(ggrepel)                                   # geom ekstra untuk ggplot2
library(viridis)                                   # skala warna
# Dataset tersedia di library gapminder
data <- gapminder %>% 
  filter(year=="2007") %>% 
  dplyr::select(-year)
# Menampilkan plot gelembung
data %>%
mutate(pop=pop/1000000) %>%
arrange(desc(pop)) %>%
mutate(country = factor(country, country)) %>%
ggplot( aes(x=gdpPercap, y=lifeExp, size = pop, color = continent)) +
  geom_point(alpha=0.7) +
  scale_size(range = c(1, 15), name="Population (M)") +
  scale_color_viridis(discrete=TRUE, guide=FALSE) +
  theme_ipsum() +
  theme(legend.position="bottom")
```

Pada grafik ini, hubungan antara `gdp` per kapita dan Angka Harapan Hidup cukup jelas: negara-negara kaya cenderung hidup lebih lama, dengan efek ambang batas ketika `gdp` per kapita mencapai ~10,000. Hubungan ini dapat dideteksi menggunakan plot sebar klasik, tetapi ukuran gelembung memungkinkan variasi hasil ini dengan tingkat informasi ketiga: populasi negara. 

namun, ini dapat membuat frustasi jika tidak mengetahui negara mana yang berbeda di bagian ekstrim dari grafik, atau negara mana yang berada di luar tren umum. Seperti biasa, memberi anotasi pada grafik adalah langkah penting untuk membuatnya berwawasan:

```{r, echo=T, results='hide'}
# Menyiapkan data
tmp <- data %>%
mutate(annotation = case_when(
  gdpPercap > 5000 & lifeExp < 60 ~ "yes",
  lifeExp < 30 ~ "yes", 
  gdpPercap > 40000 ~ "yes")) %>%
mutate(pop=pop/1000000) %>%
arrange(desc(pop)) %>%
mutate(country = factor(country, country))
# Plot
ggplot(tmp, aes(x=gdpPercap, y=lifeExp, size = pop, color = continent)) +
  geom_point(alpha=0.7) +
  scale_size(range = c(1.4, 19), name="Population (M)") +
  scale_color_viridis(discrete=TRUE) +
  theme_ipsum() +
  theme(legend.position="none") +
  geom_text_repel(data=tmp %>% filter(annotation=="yes"), aes(label=country), size=4 )
```

### Biplot

Biplot adalah grafik khusus yang mencoba mempresentasikan hubungan antara pengamatan, antara variabel, dan antara pengamatan dan variabel, di dalam ruang dimensi rendah (biasanya dua dimensi). Paling mudah untuk melihat cara kerjanya dengan sebuah contoh. Mari kita buat biplot untuk dataset `mtcars`, menggunakan fungsi `fviz_pca` dari package `factorextra`.

```{r, echo=T, results='hide'}
library(factoextra)                                # menggunakan fungsi `fviz_pca`
data(mtcars)                                       # memuat data
fit <- prcomp(x=mtcars, center=TRUE, scale=TRUE)   # mencocokkan dengan model komponen utama
fviz_pca(fit, repel = TRUE, labelsize = 3) +       # memplot hasilnya
      theme_bw() +
      labs(title = "Biplot of mtcars data")
```

`Dim1` dan `Dim2` adalah dua komponen utama - kombinasi linear dari variabel $p$ asli.

$$PC1=\beta_{10}+\beta_{11}x_1+\beta_{12}x_2+\beta_{13}x_3+...+\beta_{1p}x_p$$
$$PC2=\beta_{20}+\beta_{21}x_1+\beta_{22}x_2+\beta_{23}x_3+...+\beta_{2p}x_p$$

Bobot dari kombinasi linear ($\beta_{ij}s$) ini dipilih untuk memaksimalkan variansi yang diperhitungkan dalam variabel asli. Selain itu, komponen utama ($PCs$) dibatasi agar tidak berkorelasi satu sama lain.

Dalam grafik ini, PC pertama menyumbang 60% dari variabilitas dalam data asli. PC kedua menyumbang 24%. Bersamaan, mereka menyumbang 84% dari variabilitas dalam variabel asli $p=11$. Seperti yang Anda lihat, pengamatan (mobil) dan variabel (karakteristik mobil) diplot dalam grafik yang sama.

* Titik-titik mewakili pengamatan. Jarak yang lebih dekat antar titik menunjukkan nilai yang serupa pada kumpulan variabel asli. Misalnya, Toyota Corolla dan Honda Civic mirip satu sama lain, seperti halnya Chrysler Imperial dan Lincoln Continental. Namun, Toyota Corolla sangat berbeda dari Lincoln Continental.
* Vektor (panah) mewakili variabel. Sudut antar vektor sebanding dengan korelasi antar variabel. Contoh, `gear` dan `am` berkorelasi positif, `gear` dan `qsec` tidak berkorelasi (sudut 90 derajat), dan `am` dengan `wt` berkorelasi negatif (sudut lebih besar dari 90 derajat).
* Pengamatan yang terjauh sepanjang arah vektor variabel, memiliki nilai tertinggi pada variabel tersebut. Sebagai contoh, Toyota Corolla dan honda Civic memiliki nilai `mpg` yang lebih tinggi. Toyota Corona memiliki `qsec` yang lebih tinggi. Duster 360 memiliki lebih banyak `cyl`. Hati-hati dalam menafsirkan biplot. Mereka hanya akurat jika presentase varian yang diperhitungkan tinggi. Selalu periksa kesimpulan Anda dengan data asli.

Lihat artikel oleh [Forrest Young](http://forrest.psych.unc.edu/research/vista-frames/help/lecturenotes/lecture13/biplot.html) untuk mempelajari lebih lanjut tentang menafsirkan biplot dengan benar.

### Peta Panas (Heatmaps)

`heatmap` menampilkan sekumpulan data menggunakan ubin berwarna untuk setiap nilai variabel dalam setiap pengamatan. Mari buat peta panas untuk kumpulan data `mtcars` yang dilengkapi dengan basis R. Data set `mtcars` berisi informasi tentang 32 mobil yang diukur pada 11 variabel.

```{r, echo=T, results='hide'}
data(mtcars)
library(superheat)
superheat(mtcars,
          scale = TRUE,
          left.label.text.size=3,
          bottom.label.text.size=3,
          bottom.label.size = .05,
          row.dendrogram = TRUE )
```

Di sini terlihat bahwa Toyota Corolla dan Fiat 128 memiliki karakteristik yang mirip. Lincoln Continental dan Cadillac Fleet-wood juga memiliki karakteristik yang mirip. Fungsi `superheat` membutuhkan data dalam format tertentu. Secara khusus

* Semua data harus numerik
* Nama baris digunakan untuk melabelkan sumbu kiri. Jika label yang diinginkan ada di dalam variabel kolom
* variabel harus diubah menjadi nama baris (lebih lanjut tentang hal ini ada di bawah)
* Nilai hilang diperbolehkan

Mari kita gunakan peta-panas untuk menampilkan perubahan pada harapan hidup dari waktu ke waktu untuk negara-negara di Asia. Datanya berasal dari dataset `gapminder`.

Karena datanya di dalam format panjang, pertama-tama kita harus mengubahnya menjadi format lebar. Kemudian kita perlu memastikan bahwa ini merupakan dataframe dan mengubah variabel negara menjadi nama baris. Terakhir, kita akan mengurutkan data berdasarkan harapan hidup tahun 2007. Selagi kita melakukannya, mari kita ubah skema warnanya.

```{r, echo=T, results='hide'}
library(tidyr)                                     # manipulasi data
library(dplyr)                                     # manipulasi data
library(RColorBrewer)                              # skema warna
library(superheat)                                 # library headmap
data(gapminder, package="gapminder")               # memuat data
asia <- gapminder %>%                              # subset negara-negara Asia
  filter(continent == "Asia") %>%
  select(year, country, lifeExp)
plotdata <- spread(asia, year, lifeExp)            # mengubah dari format panjang ke format lebar
plotdata <- as.data.frame(plotdata)                # menyimpan negara sebagai nama baris
row.names(plotdata) <- plotdata$country
plotdata$country <- NULL
sort.order <- order(plotdata$"2007")               # urutan baris
colors <- rev(brewer.pal(5, "Blues"))              # warna 
# membuat heat map
superheat(plotdata,
          scale = FALSE,
          left.label.text.size=3,
          bottom.label.text.size=3,
          bottom.label.size = .05,
          heat.pal = colors,
          order.rows = sort.order,
          title = "Life Expectancy in Asia")
```

### Matriks Plot Korelasi

Plot korelasi membantu Anda memvisualisasikan hubungan berpasangan antara kumpulan variabel kuantitatif dengan menampilkan korelasinya menggunakan warna atau bayangan. Untuk mengeksplorasi hubungan antara variabel kuantitatif, kita dapat menghitung [koefisien korelasi](https://www.statisticshowto.com/probability-and-statistics/correlation-coefficient-formula/) Pearson Product-Moment.

```{r, echo=T, results='hide'}
library(dplyr)                                    # manipulasi data
library(ggplot2)                                  # visualisasi data
library(corrplot)                                 # visualisasi matriks korelasi
library(RColorBrewer)                             # membuat palet warna yang tampak bagus
data(mtcars)                                      # memuat data 
df <- dplyr::select_if(mtcars,is.numeric)         # memilih variabel numerik
corM <- cor(df, use="complete.obs")               # menghitung matriks korelasi
round(corM,2)                                     # menyesuaikan korelasi dalam dua angka dibelakang koma (dua desimal)
```

```{r, echo=T, results='hide'}
# corrplot(corM)                                  # visualisasi default dari matriks korelasi
# corrplot(corM, method="circle", type="lower")   # metode visualisasi "circle" jenis bawah
# corrplot(corM, method="pie", type="upper")      # metode visualisasi "pie" jenis atas
# corrplot(corM, method="number", type="upper",   # metode visualisasi "number" jenis atas
#          tl.col="indianred2", number.cex=0.8)
# corrplot(corM, method="number", type="upper",   # korelasi dengan `hclust` (clustering)
#          tl.col="indianred3",number.cex=0.8,
#          order="hclust")
corrplot(corM, method="number", type="upper",     # korelasi dengan `hclust` membagi 4 warna
         number.cex=0.8, tl.col="indianred4", 
         order="hclust", 
         col=brewer.pal(n=4, name="RdBu"))
```

Bagi mereka yang tertarik untuk menggambar `correlogram` ini dengan data mereka sendiri, berikut adalah kode fungsi yang saya adaptasi berdasarkan fungsi `corrplot()` dari package `corrplot` (sekali lagi terima kasih kepada semua kontributor package ini):

```{r, echo=T, results='hide'}
dat <- mtcars[, c(1, 3:7)]
# devtools::install_github("laresbernardo/lares")
library(lares)
corr_cross(dat,       # nama dataset
  max_pvalue = 0.05,  # hanya menampilkan korelasi signifikan (pada tingkat 5%)
  top = 10            # menampilkan 10 pasangan variabel teratas (berdasarkan koefisien korelasi)
)
```

Menggunakan fungsi `corr_var()` jika Anda ingin fokus pada korelasi satu variabel terhadap variabel lainnya, dan mengembalikan yang tertinggi dalam plot:

```{r, echo=T, results='hide'}
dat <- mtcars[, c(1, 3:7)]
corr_var(dat,              # nama dataset
  disp,                    # nama variabel yang akan difokuskan
  top = 5                  # menampilkan 5 korelasi teratas
) 
```

### Matriks Plot Sebar

Matriks plot sebar adalah kumpulan plot sebar yang disusun sebagai kisi atau jaring (grid). Ini mirip dengan plot korelasi tetapi bukan menampilkan korelasi, melainkan menampilkan data yang mendasarinya.

Kita dapat membuat matriks plot sebar menggunakan fungsi `ggpairs` dalam package `GGally`. Dalam hal ini, kita mengilustrasikan matriks plot sebar dengan memeriksa hubungan antara ukuran mamalia dan karakteristik tidur. Datanya berasal dari dataset `msleep` yang dikirimkan dengan `ggplot2`. Bobot otak dan bobot tubuh sangat miring (pikirkan tikus dan gajah) jadi kami akan mengubahnya menjadi log bobot otak dan log bobot tubuh sebelum membuat grafik.

```{r, echo=T, results='hide'}
library(GGally)                                    # meunggunakan fungsi `ggpairs`
library(dplyr)                                     # manipulasi data
data(msleep, package="ggplot2")                    # memuat/mempersiapkan data
msleep <- na.omit(msleep)                          # menghapus nilai hilang
df <- msleep %>% 
mutate(log_brainwt = log(brainwt),log_bodywt = log(bodywt)) %>%
select(log_brainwt, log_bodywt, sleep_total, sleep_rem)
# fungsi kostum untuk plot densitas
my_density <- function(data, mapping, ...){
  ggplot(data = data, mapping = mapping) + 
    geom_density(alpha = 0.5, fill = "indianred3", ...)
}
# fungsi kostum untuk plot sebar
my_scatter <- function(data, mapping, ...){
  ggplot(data = data, mapping = mapping) + 
    geom_point(alpha = 0.5,color = "indianred3") + 
    geom_smooth(method=lm, se=FALSE, ...)
}
# membuat matriks plot sebar
ggpairs(df, 
        lower=list(continuous = my_scatter), 
        diag = list(continuous = my_density)) +
  labs(title = "Mammal size and sleep characteristics") +
  theme_bw()
```

Kode yang Anda lihat di atas membuat Anda dapat menulis fungsi yang bersifat fleksibilitas. Selain itu, karena plot yang dihasilkan adalah grafik ggplot2, fungsi tambahan dapat ditambahkan untuk mengubah tema, judul, label, dll. Lihat [bantuan](https://cran.r-project.org/web/packages/GGally/index.html) untuk lebih jelas.

### Grafik Radar

Grafik radar (juga disebut grafik laba-laba atau grafik bintang) menampilkan satu atau lebih kelompok atau pengamatan pada tiga atau lebih variabel kuantitatif. Grafik radar dabat dibuat dengan fungsi `ggradar` dalam package `ggradar`. Sayangnya, package tersebut tidak tersedia di CRAN, jadi kita harus menginstalnya dari Github.

Dalam contoh di bawah ini, kita akan membandingkan anjing, babi, dan sapi dalam hal ukuran tubuh, ukuran ptak, dan karakteristik tidur (total waktu tidur, panjang siklus tidur, jumlah tidur REM). Datanya berasal dari dataset Mammal Sleep.

```{r, echo=T, results='hide'}
# install.packages("devtools")
# devtools::install_github("ricardo-bion/ggradar")
library(ggplot2)                                   # dataset dan visualisasi
library(dplyr)                                     # manipulasi data
library(scales)                                    # penskalaan data      
library(ggradar)                                   # visualisasi radar
data(msleep, package = "ggplot2")                  # mempersiapkan data 
plotdata <- msleep %>%
  filter(name %in% c("Cow", "Dog", "Pig")) %>%
  select(name, sleep_total, sleep_rem, 
         sleep_cycle, brainwt, bodywt) %>%
  rename(group = name) %>%
  mutate_at(vars(-group),
            funs(rescale))
# menghasilkan grafik radar
ggradar(plotdata, 
        grid.label.size = 4,
        axis.label.size = 4, 
        group.point.size = 5,
        group.line.width = 1.5,
        legend.text.size= 10) +
  labs(title = "Mammals, size, and sleep")
```

Kita dapat melihat dari grafik bahwa, secara relatif, sapi memiliki bobot otak dan bobot tubuh yang besar, siklus tidur yang panjang, total waktu tidur yang singkat, dan sedikit waktu pada tidur REM. Anjing sebagai perbandingannya, memiliki bobot tubuh dan bobot otak yang kecil, siklus tidur yang pendek, total waktu tidur yang panjang, serta waktu tidur panjang dalam REM (Kesimpulan yang jelas adalah bahwa saya ingin menjadi seekor anjing - tetapi dengan otak yang lebih besar).

### Awan Kata

Awan kata (juga disebut awan penanda), pada dasarnya merupakan infografis yang menunjukkan frekuensi kata dalam kumpulan teks (mis., Tweet, dokumen teks, sekumpulan dokumen teks). Ada skrip yang sangat bagus yang dibuat oleh STHDA yang akan menghasilkan awan kata langsung dari file teks. Untuk mendemonstrasikan, kita akan memproses ["I have a dream speech"](http://www.sthda.com/sthda/RDoc/example-files/martin-luther-king-i-have-a-dream-speech.txt) dari "Martin Luther King".

```{r, echo=T, results='hide'}
library("tm")                                      # untuk penggalian teks
library("SnowballC")                               # untuk membendung teks
library("wordcloud")                               # generator awan kata
library("RColorBrewer")                            # palet warna
text <- readLines("Data/speech.txt")               # membaca file teks dari PC Anda
docs <- Corpus(VectorSource(text))                 # memuat data sebagai korpus
# transformasi teks
toSpace <- content_transformer(function(x, 
                pattern) gsub(pattern, " ", x))
docs <- tm_map(docs,toSpace, "/")
docs <- tm_map(docs,toSpace, "@")
docs <- tm_map(docs,toSpace, "\\|")
docs <- tm_map(docs,content_transformer(tolower)) # mengubah teks menjadi huruf kecil
docs <- tm_map(docs,removeNumbers)                # menghapus angka-angka
docs <- tm_map(docs,removeWords,                 
               stopwords("english"))              # hapus kata sandi umum berbahasa Inggris
docs <- tm_map(docs, removeWords, 
               c("blabla1", "blabla2"))           # tentukan kata sandi Anda sebagai vektor karakter
docs <- tm_map(docs, removePunctuation)           # menghapus tanda baca
docs <- tm_map(docs, stripWhitespace)             # menghilangkan ruang putih ekstra
# membuat matriks dokumen istilah
dtm <- TermDocumentMatrix(docs)
m <- as.matrix(dtm)
v <- sort(rowSums(m),decreasing=TRUE)
d <- data.frame(word = names(v),freq=v)
# pentingnya kata-kata dapat diilustrasikan sebagai awan kata sebagai berikut:
set.seed(1234)
wordcloud(words = d$word, freq = d$freq, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))
```

## Grafik Interaktif

Pada bagian ini, kita akan menunjuk beberapa opsi terbaik untuk menghasilkan grafik interaktif yang dapat ditempatkan di halaman web. Sehingga Anda dapat mengeksplorasinya lebih jauh pada grafik atau gambar yang dapat ditempatkan pada makalah, poster, slide, dan artikel jurnal. Kita dapat menerapkan salah satu [`widget HTML`](http://gallery.htmlwidgets.org/) yang paling sering digunakan untuk R dengan menggunakan library `JavaScript`.

**Catatan:** Jika Anda membaca ini di iPad, beberapa fitur tidak akan tersedia (seperti mengarahkan mouse)

### leaflet

Leaflet adalah library JavaScript untuk peta interaktif. Package ini dapat digunakan untuk menghasilkan grafik leaflet R. Berikut ini adalah contoh sederhananya. Sama seperti dygraphs, Anda menjelajahi peta dengan mengklik pin, memperbesar dan memperkecil dengan tombol +/- atau mouse wheel (scroll), dan menyeret peta dengan kursor tangan.

```{r, echo=T, results='hide'}
library(leaflet)                                  # membuat grafik leaflet
leaflet() %>%
   addTiles() %>%
   addMarkers(lng=174.768958, lat=-36.852656, 
             popup="The birthplace of R </br>
                    University of Auckland")
```

Untuk opsi lebih lanjut tentang [leaflet](https://rstudio.github.io/leaflet/json.html).

### plotly

`Plotly` adalah layanan komersial dan juga produk open source untuk membuat visualisasi interaktif kelas atas. Package ini memungkinkan Anda membuat grafik interaktif `plotly` dari dalam R. Selain itu, grafik ggplot2 apa pun dapat diubah menjadi grafik `plotly`.

Dengan menggunakan data [Fuel Economy](https://bookdown.org/BaktiSiregar/data-science-for-beginners/Advanced-Visualizations.html), kita akan membuat grafik interaktif yang menampilkan jarak tempuh jalan raya vs. perpindahan mesin menurut kelas mobil. Mengarahkan mouse ke suatu titik akan menampilkan informasi tentang titik tersebut. mengklik pada titik legend akan menghapus kelas tersebut dari plot. Mengkliknya lagi akan mengembalikannya.

```{r, echo=T, results='hide'}
library(ggplot2)                                  # visualiSasi data
library(plotly)                                   # visualisasi interaktif
library(htmlwidgets)                              # menyimpan html
p <- ggplot(mpg, aes(x = displ, 
                     y = hwy, 
                 color = class)) +
      geom_point(size=2) +
      theme_bw()+
      labs(x = "Engine displacement",
           y = "Highway Mileage",
       color = "Car Class") 
ggplotly(p)
#htmlwidgets::saveWidget(ggplotly(p),"plotly.html") # menyimpan html 
```

Ada beberapa sumber informasi yang bagus tentang plotly. Lihat [halaman R plotly](https://plot.ly/r/) dan [plotly untuk R book](https://plotly-book.cpsievert.me/) online. Selain itu, DataCamp menawarkan [tutorial interaktif](https://www.datacamp.com/community/blog/a-free-interactive-plotly-r-tutorial) gratis.

### rbokeh

`rbokeh` adalah antarmuka ke pustaka grafik Bokeh. Kita akan membuat grafik lain menggunakan dataset `mtcars`, yang meunjukkan perpindahan mesin vs. mil per galon menurut jumlah silinder mesin. Arahkan mouse, dan coba berbagai kontrol di sebelah kanan gambar. 

```{r, echo=T, results='hide'}
library(rbokeh)                                   # plot interaktif dengan `rbokeh`
data(mtcars)                                      # mempersiapkan/memuat data 
mtcars$name <- row.names(mtcars)                  # membuat variabel baru berdasarkan nama baris `mtcars`
mtcars$cyl <- factor(mtcars$cyl)                  # menandakan variabel `cyl` sebagai faktor
b<-figure() %>%                                       # buat grafik 
    ly_points(disp, mpg, data=mtcars,
    color = cyl, glyph = cyl,
    hover = list(name, mpg, wt))
b
#htmlwidgets::saveWidget(bokeh, "b.html")        # menyimpan html 
```

Lebih lanjut mengenai [`rbokeh`](https://hafen.github.io/rbokeh/articles/rbokeh.html).

### rCharts

`rCharts` menggunakan antarmuka rumus untuk menentukan plot, seperti package kisi/jaring (lattice). Berikut adalah beberapa contoh yang dapat Anda coba untuk membuat berbagai grafik interaktif di konsol R Anda:

**NVD3** adalah library `d3js` favorit saya, yang menghasilkan visualisasi interaktif yang luar biasa dengan sedikit penyesuaian. Contoh berikut menunjukkan grafik batang dari warna rambut vs. warna mata. Coba arahkan mouse ke atas batang. Anda dapat memilih secara interaktif antara plot yang dikelompokkan vs. plot yang bertumpuk dan menyertakan atau mengecualikan kasus menurut warna mata.

```{r, echo=T, results='hide'}
require(devtools)                                  # untuk mendownload package yang dibutuhkan dari Github
install_github('ramnathv/rCharts')                 # menginstal package dari Github
library(rCharts)                                   # memuat package
hair_eye_male<-subset(as.data.frame(HairEyeColor), # menyaring data
                      Sex == "Male")
n <- nPlot(Freq ~ Hair, 
           group = 'Eye', 
           data = hair_eye_male, 
           type = 'multiBarChart')
n$set(width = 800, pointSize = 0, lineWidth = 1)   # mengatur skala, ukuran titik, lebar garis
n$save('HTML/NVD3.html', standalone = TRUE)        # menyimpan hasil sebagai html
shiny::includeHTML("HTML/NVD3.html")               # membuka hasilnya
```

Library berikutnya yang akan kita jelajahi adalah **Morris**

```{r, echo=T, results='hide'}
data(economics, package = 'ggplot2')
econ <- transform(economics, 
                  date = as.character(date))
m <- mPlot(x = 'date',
           y = c('psavert', 'uempmed'), 
        type = 'Line', data = econ)
m$set(width = 800, pointSize = 0, lineWidth = 1)   # mengatur skala, ukuran titik, lebar garis
m$save('HTML/Morris.html', standalone = TRUE)      # menyimpan hasilnya sebagai html
shiny::includeHTML("HTML/Morris.html")             # membuka hasilnya
```

Lebih lanjut tentang [`rCharts`](https://rpubs.com/dnchari/rcharts).

### googleVis

Contoh-contoh berikut diambil dari demo `googleVis`. Anda dapat menjalankan demo melalui

```{r, echo=T, results='hide'}
library(googleVis)                                # grafik interaktif
library(htmlwidgets)                              # menyimpan html
# demo(googleVis)
set.seed(123)
datHist=data.frame(A=rpois(100, 20),
                   B=rpois(100, 5),
                   C=rpois(100, 50))

Hist <- gvisHistogram(datHist, options=list(
  legend="{ position: 'top', maxLines: 2 }",
  colors="['#5C3292', '#1A8763', '#871B47']",
  width=800, height=600))
plot(Hist)
```

Lebih lanjut mengenai [`googleVis`](https://cran.r-project.org/web/packages/googleVis/vignettes/googleVis_examples.html).

### Mengungkap Package

Ada beberapa package untuk grafik interaktif (tidak tercakup dalam buku ini), silakan kunjungi situs berikut jika Anda tertarik:

* [`dygraphs`](https://rstudio.github.io/dygraphs/gallery-series-options.html)
* [`highcharter`](http://jkunst.com/highcharter/showcase.html)

## Animasi Interaktif

Grafik animasi interaktif menampilkan beberapa status grafik satu demi satu. Ketika membuat animasi, plotnya tidak bergerak. Sebaliknya, banyak plot individual dibangun dan kemudian digabungkan bersama menjadi bingkai film, seperti flip-book atau kartun jadul. Setiap bingkai adalah plot yang berbeda saat menyampaikan gerakan, yang dibangun menggunakan beberapa himpunan bagian yang relevan dari data agregat.Himpunan bagian mendorong aliran animasi saat digabungkan kembali.

<center>
<img src="D:/Matana University/Data Scientist Handbook/Data-Science-Untuk-Pemula/Interactive Animation (chapter 8.4).png" style = "width:100%;">
</center>

Ada empat opsi package yang biasanya saya gunakan untuk menganimasikan data di R:

### plotly (interaktif)

Package pertama yang dibahas di sini adalah `plotly`. Ada hubungan cinta/benci dengan banyak praktisi visualisasi dan package ini. Ini memungkinkan pembuatan plot interaktif yang indah dan sederhana. Namun, dengan kemudahan datang beberapa kerugian dalam fleksibilitas dan gaya. Anda juga harus berurusan dengan logo `plotly` dalam segala hal. Namun, saya pribadi berpikir trade-off biasanya sepadan. Berikut ini adalah contoh animasi dari dokumen `plotly` (menggunakan argumen frame) dari dataset `gapminder` yang sama yang kita lihat dengan package `gganimate`:

```{r, echo=T, results='hide'}
library(gapminder)
library(plotly)
library(htmlwidgets)
df <- gapminder 
fig <- df %>%
  plot_ly(
    x = ~gdpPercap, 
    y = ~lifeExp, 
    size = ~pop, 
    color = ~continent, 
    frame = ~year, 
    text = ~country, 
    hoverinfo = "text",
    type = 'scatter',
    mode = 'markers'
  )
fig <- fig %>% layout(
    xaxis = list(
      type = "log"
    )
  )

fig <- fig %>%
  animation_opts(
    1000, easing = "elastic", redraw = FALSE
  )
```

### gganimate

Hal terpenting tentang visualisasi adalah ketika visualisasi memaksa kita untuk menyadari sesuatu yang tidak kita ketahui. Grafik yang menarik secara visual dengan mudah menarik perhatian kita. Menganimasikan data seperti menghembuskan kehidupan ke debu, ini adalah tindakan penciptaan. Bagaimana Anda membuat animasi menarik yang berwawasan? Pada artikel ini, kita akan belajar cara membuat animasi yang indah menggunakan package R, `gganimate`.

**Contoh:** Data Tingkat Bunuh Diri didapatkan dari [Kaggle](https://www.kaggle.com/russellyates88/suicide-rates-overview-1985-to-2016) setelah dikumpulkan dari berbagai sumber (WHO, UNDP, World Bank). Data tersebut membandingkan info sosial ekonomi dengan tingkat bunuh diri per negara dari tahun 1985 hingga 2016. Inspirasinya adalah untuk menghasilkan strategi pencegahan bunuh diri di berbagai negara.

#### Langkah Pertama {-}

Mari kita lihat bagaimana kita mengumpulkan, memanipulasi, dan membangun grafik batang untuk dataset ini menggunakan `ggplot`.

```{r, echo=T, results='hide'}
# memuat library yang dibutuhkan
library(tidyverse)
library(reshape2)
library(ggthemes)
library(gganimate)
library(gifski)
# memuat dataset
suicide_data<-read.csv("Data/master.csv",
                       header = TRUE,
                       stringsAsFactors = FALSE)
# memilih kolom untuk dikerjakan 
suicide_sub<-suicide_data %>% 
  select("ï..country","year" ,"sex","suicides_no")%>% 
  rename("country"="ï..country" )
# fungsi untuk menjumlahkan total bunuh diri per negara
n<-unique(suicide_sub$country)
country<-function(x){
  suicide2<-suicide_sub %>% filter(country==x)
  sum(suicide2$suicides_no)
}
# mengembalikan daftar dengan semua total kematian per negara
country_total<-sapply(n,function(x) country(x))
# membuat dataframe dengan total 10 kasus bunuh diri teratas per negara
df<-do.call(rbind,Map(data.frame,Country=n,Total_Suicides=country_total))
df2<-df %>% arrange(desc(Total_Suicides))
df3<-head(df2,n=10)
write.csv(df3,"Data/total_suicide.csv")
# memplot 10 negara teratas yang memimpin total tingkat bunuh diri
ggplot(df3,aes(reorder(Country,Total_Suicides),
               Total_Suicides,
               fill=as.factor(Country)))+
    geom_col()+
    theme_bw()+
    coord_flip(clip = "off", expand = FALSE)+
    guides( fill = FALSE) +
    labs(title="Top 10 Total Suicide Deaths Per-contry from 1985-2016", 
         y="Total Suicides", x="Country")+
    scale_y_continuous(labels = scales::comma) +
     geom_text(aes(label = paste(Total_Suicides,"")), hjust = 1)

# gunakan `ggplotly()` untuk menampilkan plot yang interaktif jika Anda mau
```

#### Langkah Kedua {-}

Membangun grafik batang statis kita sebagai berikut:

```{r, echo=T, results='hide'}
library(dplyr)
# subset data awal dengan 10 negara teratas
top_suicide<-suicide_sub %>%
  filter(country==c("Russian Federation","United States",
                     "Japan","France","Ukraine","Germany",
                     "Republic of Korea","Brazil","Poland",
                     "United Kingdom"))
# menyaring tahun dengan data yang konsisten
top_suicide2<-top_suicide %>%
  filter(year %in%c(1990:2014)) 
top_suicide2$sex<-as.factor(top_suicide2$sex)
# menjumlah total kasus bunuh diri laki-laki dan perempuan per negara untuk setiap tahun
sm3<-aggregate(suicides_no~country+year,top_suicide2,sum)
# memastikan kita memiliki peringkat non-integer saat meluncur
sm4<-sm3 %>%
  group_by(year) %>% 
  mutate(rank = min_rank(-suicides_no) * 1) %>%
  ungroup()
# memplot plot statis
static_plot<-ggplot(sm4,aes(rank,
                            group=country,
                            fill=as.factor(country),
                            color=as.factor(country))) +
  geom_tile(aes(y = suicides_no/2,
    height = suicides_no,
    width = 0.9), alpha = 0.8, color = NA) +
  geom_text(aes(y = 0, label = paste(country, " ")), vjust = 0.2, hjust = 1)+
  geom_text(aes(y=suicides_no,label = paste(" ",suicides_no)), hjust=0)+
  coord_flip(clip = "off", expand = TRUE) +
  scale_y_continuous(labels = scales::comma) +
  scale_x_reverse() +
  guides(color = FALSE, fill = FALSE) +
  theme_minimal() +
    theme(
    plot.title=element_text(size=25, hjust=0.5, face="bold", colour="grey", vjust=-1),
    plot.subtitle=element_text(size=18, hjust=0.5, face="italic", color="grey"),
    plot.caption =element_text(size=8, hjust=0.5, face="italic", color="grey"),
    axis.ticks.y = element_blank(), 
    axis.text.y = element_blank(), 
    plot.margin = margin(1,1,1,4, "cm"))
static_plot
```

#### Langkah Ketiga {-}

Ini merupakan langkah terakhir untuk membuat plot animasi kita menggunakan `gganimate`, perhatikan kode berikut ini:

```{r, echo=T, results='hide'}
# membuat animasi terakhir
plt<-static_plot + 
  transition_states(states = year, transition_length = 4, state_length = 1) + 
  ease_aes('cubic-in-out') +
#view_follow(fixed_x = TRUE) +
 labs(title = 'Total Suicides per Year : {closest_state}', 
 subtitle = "Top 10 Countries",
 caption = "Data Source: World Bank Data",
 x="Countries",y="Total Suicides per year")
# mengubah animasi menjadi bentuk gif
final_animation<-animate(plt,100,
                         fps = 20,
                         duration = 30, 
                         width = 950, 
                         height = 750, 
                         renderer = gifski_renderer())
# mengubah animasi menjadi bentuk mp4
# animate(plt,100,
#         fps = 20,
#         duration = 30, 
#         width = 950, 
#         height = 750, 
#         renderer = ffmpeg_renderer())
# menyimpan animasi
anim_save("images/suicide_animate.gif",animation=final_animation)
```

#### Fitur Utama dari `gganimate` {-}

* `transition_`: fungsi ini menentukan bagaimana data harus disebarkan dan bagaimana hubungannya dengan dirinya sendiri dari waktu ke waktu.
  * `transition_reveal`: ini memungkinkan Anda membiarkan data menghilang secara bertahap.
  * `transition_time`: panjang transisi antar negara bagian diatur agar sesuai dengan perbedaan waktu aktual di antara keduanya.
  * `transition_state`: ini digunakan untuk menganimasikan plot berdasarkan variabel kategori atau diskrit.
* `view_`: ini digunakan untuk menentukan bagaimana sumbu harus berubah seiring dengan animasinya.
  * `view_follow(fixed_y=TRUE)`: ini berarti sumbu y akan tetap ketika animasi dijalankan.
  * `view_follow(fixed_x=TRUE)`: sumbu x akan tetap saat animasi dijalankan.
* `ease_aes()`: ini menjelaskan bagaimana estetika yang berbeda harus dikurangi selama animasi.
  * `ease_aes("cubic-in-out")`
  * `ease_aes("sine-in-out")`
* `enter_/exit_`: ini digunakan untuk menentukan bagaimana data baru harus muncul dan data lama menghilang selama proses animasi atau Anda menggunakan `enter_fade/exit_shrink`
* `State_length`: ini mengacu pada panjang relatif dari jeda negara bagian
* `transition_length`: ini adalah panjang relatif animasi
* Rendering: ini adalah jenis komputasi untuk menampilkan hasil akhir. Parameter yang digunakan antara lain:
  * `nframes`: ini mengatur jumlah frame yang digunakan (defaultnya adalah 100)
  * Frame per `second(fps)`: ini adalah jumlah waktu yang dihabiskan pada setiap frame per detik (defaultnya adalah 10) 
  * Renderer: ini mengatur fungsi untuk menggabungkan setiap frame menjadi sebuah animasi (defaultnya `gifski_renderer()`)
  * Jika kita ingin mengakhiri loop, kita gunakan: `renderer=gifski_renderer(loop=FALSE)`. Untuk menyimpan plot animasi sebagai vidio, kita gunakan `renderer=ffmpeg_renderer()`.
* Duration: ini adalah total waktu yang dibutuhkan frame untuk beranimasi, yaitu `duration=30`. 
* Layout: Kita dapat mengubah tinggi dan lebar plot kita dengan menentukan ukurannya. Kita menyimpan hasil animasi ke sebuah objek, misalnya disebut `final_animation`.
* Untuk menyimpan animasi kita, kita akan menggunakan fungsi `anim_save()` dengan parameter: 
  * Animation: ini adalah hasil akhir dari plot animasi kita.
  * Path: lokasi di mana kita ingin menyimpan animasi kita.

Lebih lanjut mengenai [`gganimate`](https://github.com/thomasp85/gganimate).

### animation

Package ini bagus, khususnya karena memiliki grafik statistik yang luar biasa sebagai contoh. Ini adalah salah satu yang menganimasikan penurunan gradien dan membuat haliman HTML dengan kontrol: 

```{r, echo=T, results='hide'}
library(animation)
saveGIF({ani.options(interval = 1)
par(mar = c(3, 3, 1, 1.5), mgp = c(1.5, 0.5, 0))
kmeans.ani()})
```

**Penting:** Anda dapat klik [di sini](https://yihui.org/animation/) untuk mengetahui lebih lanjut mengenai package `animation`.

<!--chapter:end:08-Vusualisasi-Data-Lanjut.Rmd-->

`r if (knitr:::is_html_output()) '
# Daftar-Pustaka {-}
'`

<!--chapter:end:09-Daftar-Pustaka.Rmd-->

