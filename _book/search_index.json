[
["3-Pemrograman-R.html", "Chapter 3 Pemrograman R 3.1 Apa itu Pemrograman? 3.2 Algoritma Kehidupan Nyata 3.3 Mengapa Mempelajari Algoritma? 3.4 Bagaimana Menulis Fungsi di R 3.5 Contoh Kasus Sederhana 3.6 Struktur Kontrol 3.7 Fungsi Loop", " Chapter 3 Pemrograman R 3.1 Apa itu Pemrograman? Pemrograman yaitu aktivitas membuat program, yaitu menyusun sejumlah perintah yang dikenal computer. Terstruktur dapat berarti terpola, bentuk yang mengikuti aturan tertentu, juga berarti sesuatu yang sistematis. Berikut ini adalah suatu ilustrasi yang terjadi dalam algortima. Figure 3.1: Proses Algoritma Ada banyak sekali definisi tentang apa itu pemrograman, di sini saya mengumpulkan empat frasa kunci diantaranya: Pemrograman adalah proses pengambilan algoritma dan pengkodeannya menjadi suatu notasi, sehingga bahasa pemrograman dapat dieksekusi oleh komputer. Meskipun banyak bahasa pemrograman dan berbagai jenis komputer, langkah pertama yang penting adalah kebutuhan untuk memiliki solusi. Tanpa algoritma, tidak akan ada program. Ilmu komputer bukanlah studi tentang pemrograman. Pemgrograman, bagaimanapun, adalah bagian penting dari apa yang dilakukan ilmuwan komputer. Pemrograman sering kali merupakan cara kita membuat representasi dari solusi kita. Oleh karena itu, representasi bahasa dan proses pembuatannyamenjadi bagian fundamental dari disiplin ilmu. Algoritma menggambarkan solusi untuk suatu masalah dalam hal data yang dibutuhkan untuk mewakili contoh masalah dan serangkaian langkah yang diperlukan untuk menghasilkan hasil yang diinginkan. Bahasa pemrograman harus menyediakan cara notasional untuk merepresentasikan proses dan data. Untuk tujuan ini, bahasa menyediakan konstruksi kontrol dan jenis data. Konstruksi kontrol memungkinkan langkah-langkah algoritmik dipresentasikan dengan cara yang nyaman namun tidak ambigu. Minimal, algoritma memerlukan konstruksi yang melakukan pemrosesan sekuensial, pemilihan untuk pengambilan keputusan, dan iterasi untuk kontrol berulang. Selama bahasa memberikan pernyataan dasar ini, itu dapat digunakan untuk representasi algoritma. Dalam Kata Sederhana: Pemrograman adalah bagaimana Anda mendapatkan komputer untuk memecahkan masalah. 3.2 Algoritma Kehidupan Nyata Mari kita ambil situasi kehidupan nyata untuk membuat kita lebih memahami tentang algoritma ini, apa itu petunjuk langkah demi langkah yang tepat mengenai bagaimana Anda menelepon teman di telepon? Langkah-langkah: Angkat telepon dan dengarkan nada panggil Tekan setiap digit nomor telepon di telepon Jika sibuk, tutup telepun, tunggu 5 menit, ulangi langkah kedua Jika tidak ada jawaban, tinggalkan pesan dan tutup Jika tidak ada mesin penjawab, tutup telepon dan tunggu 2 jam, kemudian ulangi langkah kedua Berbicara dengan teman Tutup telepon Asumsi: Langkah pertama mengasumsikan bahwa Anda tinggal sendiri dan tidak ada orang lain yang dapat menjawab telepon. Algoritma ini mengasumsikan keberadaan telepon yang berfungsi dan layanan aktif. Algoritma ini mengasumsikan Anda tidak tuli atau bisu. Algoritma ini mengasumsikan telepon yang dijalin dengan tali normal. 3.3 Mengapa Mempelajari Algoritma? Secara singkat, karena waktu adalah uang. Energi adalah uang. Dan komputer dirancang untuk mengoptimalkan keduanya. Sayangnya, komputer hanya melakukan apa yang Anda perintahkan untuk komputer lakukan serta apa yang komputer pilih untuk diingat. Tugas kita adalah mencari tahu apa yang harus diberitahukan kepada komputer dan bagaimana caranya. Salah satu cara terbaik untuk meningkatkan jangkauan Anda sebagai seorang data scientist adalah dengan menulis fungsi. Fungsi memungkinkan Anda mengotomatiskan tugas-tugas umum dengan cara yang lebih kuat dan umum daripada salin dan tempel. Fungsi sering kali digunakan untuk merangkum barisan ekspresi yang perlu dilakukan berulangkali, mungkin dalam kondisi yang berbeda. FUngsi juga sering ditulis ketika ingin membagikan kode dengan orang lain atau publik. 3.4 Bagaimana Menulis Fungsi di R Dalam beberapa kesempatan, kita perlu menulis fungsi kita sendiri karena kita harus menyelesaikan tugas terntentu dan tidak ada fungsi yang siap dipakai. Fungsi yang ditentukan pengguna melibatkan nama, argumen, dan isi. 3.4.1 Fungsi Satu Argumen Fungsi menerima nilai dan mengembalikan kuadrat dari nilai tersebut. function.name &lt;- function(arguments) { computations on the arguments some other code } Contoh (kuadrat) square_function&lt;- function(x) { x^2 # menghitung kuadrat dari `x` } square_function(4) # memanggil fungsi dan melihat nilainya ## [1] 16 Contoh (akar_kuadrat) square_root&lt;- function(x) { sqrt(x) # menghitung akar kuadrat dari `x` } square_root(4) # memanggil fungsi dan melihat nilainya ## [1] 2 Contoh (rata-rata) average&lt;- function(x) { sum(x)/length(x) # menghitung rata-rata dari `x` } x&lt;-c(1,2,3,4,5,6) average(x) # memanggil fungsi dan melihat nilainya ## [1] 3.5 3.4.2 Fungsi Multi Argumen Kita dapat menulis fungsi dengan lebih dari satu argumen. Pertimbangkan fungsi yang disebut “times”. Ini adalah fungsi langsung yang mengalikan dua variabel. function.name &lt;- function(argument1, argument2,...., argument_n) { computations on the arguments some other code } Contoh (perkalian) times &lt;- function(x,y) { x*y # menghitung (perkalian x dan y) } times(2,4) # memanggil fungsi dan melihat nilainya ## [1] 8 Contoh (volume) volume&lt;- function(p,l,t) { p*l*t } volume(5,4,3) ## [1] 60 Contoh (frek_rata-rata) avarage_freq &lt;- function(x,freq) { sum(x*freq)/length(x) } x&lt;-c(1,2,3,4,5) freq&lt;-c(4,5,6,6,6) avarage_freq(x,freq) ## [1] 17.2 Contoh (frek_rata-rata_komentar) avarage_freq_comment &lt;- function(x,freq) { avarage &lt;-sum(x*freq)/length(x) result &lt;- paste(&quot;Avarage Frequency is&quot;, sep = &quot; &quot;, avarage) return(result) } avarage_freq_comment(x,freq) ## [1] &quot;Avarage Frequency is 17.2&quot; 3.5 Contoh Kasus Sederhana Untuk membuat fungsi di R, Anda akan membuat dan mengubah skrip R. Kita tahu bahwa cara terbaik untuk belajar berenang adalah dengan melompat ke tempat yang dalam, jadi mari kita tulis fungsi untuk menunjukkan kepada Anda betapa mudahnya hal ini di R. 3.5.1 Normalisasi Seperti yang telah saya sebutkan sebelumnya, data scientist perlu melakukan banyak tugas berulang kali. Sering kali, kita menyalin dan menempelkan potongan kode berulang kali. Contoh lain, normalisasi variabel sangat disarankan sebelum kita menjalankan algoritma machine learning. Rumus untuk menormalkan variabel adalah: \\[normalisasi = \\frac{x-x_{min}}{x_{max}-x_{min}}\\] Sekarang, mari buat kerangka data seperti yang telah kita pelajari di dasar-dasar R bagian terakhir. set.seed(123) # untuk memastikan kita mendapatkan data yang sama df&lt;- data.frame( # membuat dataframe a = rnorm(10, 5, 1), # vektor `a` dengan bilangan acak normal b = rnorm(10, 5, 1), # vektor `b` dengan bilangan acak normal c = rnorm(10, 5, 1) # vektor `c` dengan bilangan acak normal ) df # cetak hasil dataframe ## a b c ## 1 4.439524 6.224082 3.932176 ## 2 4.769823 5.359814 4.782025 ## 3 6.558708 5.400771 3.973996 ## 4 5.070508 5.110683 4.271109 ## 5 5.129288 4.444159 4.374961 ## 6 6.715065 6.786913 3.313307 ## 7 5.460916 5.497850 5.837787 ## 8 3.734939 3.033383 5.153373 ## 9 4.313147 5.701356 3.861863 ## 10 4.554338 4.527209 6.253815 Kita sudah mengetahui cara menggunakan fungsi min() dan max() di R. Oleh karena itu kita dapat menggunakan rumus normalisasi yang kita miliki di atas untuk mendapatkan nilai normalisasi df sebagai berikut: df.norm &lt;- data.frame( a = (df$a -min(df$a))/(max(df$a)-min(df$a)), b = (df$b -min(df$b))/(max(df$b)-min(df$b)), c = (df$c -min(df$c))/(max(df$c)-min(df$c)) ) df.norm # cetak hasil dataframe ## a b c ## 1 0.2364281 0.8500528 0.2104635 ## 2 0.3472617 0.6197981 0.4994777 ## 3 0.9475335 0.6307099 0.2246853 ## 4 0.4481587 0.5534256 0.3257267 ## 5 0.4678825 0.3758531 0.3610444 ## 6 1.0000000 1.0000000 0.0000000 ## 7 0.5791625 0.6565733 0.8585184 ## 8 0.0000000 0.0000000 0.6257648 ## 9 0.1940214 0.7107903 0.1865516 ## 10 0.2749546 0.3979789 1.0000000 Namun, metode ini rawan akan kesalahan. Kita bisa menyalin dan lupa mengganti nama kolom setelah menempel. Oleh karena itu, praktik yang baik adalah menulis fungsi setiap kali anda perlu menempelkan kode yang sama lebih dari dua kali. Kita dapat mengatur ulang kode menjadi rumus dan memanggilnya kapan pun diperlukan. Mari pertimbangkan dengan cermat fungsi ini: normalize &lt;- function(x){ norm &lt;- (x-min(x))/(max(x)-min(x)) return(norm) } df$a&lt;-normalize(df$a) df$b&lt;-normalize(df$b) df$c&lt;-normalize(df$c) df ## a b c ## 1 0.2364281 0.8500528 0.2104635 ## 2 0.3472617 0.6197981 0.4994777 ## 3 0.9475335 0.6307099 0.2246853 ## 4 0.4481587 0.5534256 0.3257267 ## 5 0.4678825 0.3758531 0.3610444 ## 6 1.0000000 1.0000000 0.0000000 ## 7 0.5791625 0.6565733 0.8585184 ## 8 0.0000000 0.0000000 0.6257648 ## 9 0.1940214 0.7107903 0.1865516 ## 10 0.2749546 0.3979789 1.0000000 Meskipun contohnya sederhana, kita dapat menyimpulkan kekuatan rumus. Kode di atas lebih mudah dibaca dan terutama menghindari kesalahan saat menempelkan kode. Kita juga akan meningkatkan fungsi ini lebih efektif di bagian selanjutnya setelah Anda mempelajari cara menggunakan for() dan apply(). 3.5.2 Persen Misalkan Anda ingin menyajikan bilangan pecahan sebagai persentase, yang dibulatkan dengan baik menjadi satu digit desimal. Berikut cara mencapainya: Kalikan angka pecahan dengan 100. Bulatkan hasil ke satu desimal: Anda dapat menggunakan fungsi round() untuk melakukan ini. Tempelkan tanda persentase setelah angka yang dibulatkan: Fungsi paste() siap melayani Anda untuk memenuhi tugas ini. Cetak hasilnya: Fungsi print() akan melakukan ini. Anda dapat dengan mudah menerjemahkan langkah-langkah ini ke dalam skrip kecil untuk R. Jadi, buka file skrip baru di editor Anda dan ketikkan kode berikut: x &lt;- c(0.8765, 0.4321, 0.1234, 0.05678) percent &lt;- round(x * 100, digits = 1) result &lt;- paste(percent, sep = &quot; in &quot;, &quot;%&quot;) print(result) ## [1] &quot;87.6 in %&quot; &quot;43.2 in %&quot; &quot;12.3 in %&quot; &quot;5.7 in %&quot; Untuk membuat skrip ini menjadi sebuah fungsi, Anda perlu melakukan beberapa hal. Lihatlah skrip sebagai pabrik kecil yang mengambil bahan angka mentah dan memolesnya hingga mengkilap yang diinginkan setiap ahli matematika. Pertama, Anda harus membangun gedung pabrik, sebaiknya yang memiliki alamat sehingga orang tahu ke mana harus mengirim nomor mereka. Kemudian Anda harus memasang gerbang depan sehingga Anda dapat memasukkan nomor mentahnya. Selanjutnya, Anda membuat jalur produksi untuk mengubah nomor tersebut. Terakhir, Anda harus memasang gerbang belakang sehingga Anda dapat mengirimkan persentase berkilau Anda dalam dunia. Untuk membangun pabrik Anda, ubah skrip ke kode berikut: addPercent &lt;- function(x){ percent &lt;- round(x * 100, digits = 1) result &lt;- paste(percent, sep = &quot;&quot;, &quot;%&quot;) return(result) } Jika Anda menyimpan skrip ini sebagai file .R: misalnya, addPercent.R ke komputer / PC Anda di dalam folder. Kemudian Anda sekarang dapat memanggil skrip ini di konsol dengan perintah berikut: source(&#39;Functions/addPercent.R&#39;) # pastikan working directory Anda benar x&lt;-normalize(df$a) # menggunakan data yang dinormalisasi seperti yang kita miliki di atas addPercent(x) # menetapkan x sebagai persen dengan menggunakan fungsi ## [1] &quot;23.6%&quot; &quot;34.7%&quot; &quot;94.8%&quot; &quot;44.8%&quot; &quot;46.8%&quot; &quot;100%&quot; &quot;57.9%&quot; &quot;0%&quot; &quot;19.4%&quot; ## [10] &quot;27.5%&quot; 3.6 Struktur Kontrol Pada dasarnya, struktur kontrol memungkinkan Anda untuk memasukkan beberapa “logika” ke dalam kode R Anda, daripada hanya mengeksekusi kode R yang sama setiap saat. Struktur kontrol memungkinkan Anda untuk merespons input atau fitur data dan mengeksekusi ekspresi R yang berbeda. Struktur kontrol yang umum digunakan adalah if dan else menguji suatu kondisi dan menindaklanjutinya for mengeksekusi loop beberapa kali while menjalankan loop saat kondisi benar repeat menjalankan loop tak terbatas (harus keluar dari itu untuk berhenti) break mengeksekusi fraagmen loop yang rusak next melewati interasi dari sebuah loop Sebagian besar struktur kontrol tidak digunakan dalam sesi interaktif, melainkan saat menulis fungsi atau ekspresi yang lebih panjang. Namun, konstruksi ini tidak harus digunakan dalam fungsi dan ada baiknya Anda memahaminya sebelumnya. 3.6.1 if-else Kombinasi if-else mungkin adalah struktur kontrol yang paling umum digunakan di R (bahkan untuk semua bahasa pemrograman lainnya). Struktur ini memungkinkan Anda untuk menguji suatu kondisi dan menindaklanjutinya bergantung pada benar atau salah. Anda dapat memiliki serangkaian pengujian dengan mengikuti inisial if dengan else if dan else. Fungsi umumnya adalah sebagai berikut: if (condition1) { do something } else if (condition2) { do something different compare to condition1} else (optional){ do something different compare to others} Diagram berikut adalah representasi grafis dari langkah-langkah yang dilakukan dalam urutan penyajian aliran algoritma, alur kerja atau proses untuk menguntrol suatu fungsi yang menggunakan kondisi if-else. Figure 3.2: Diagaram alur if-else x &lt;- runif(1, 0, 100) # mengambil satu bilangan acak dari 0 sampai 100 ifelse &lt;- function(x){ if (x&gt;80){ # kondisi 1 print(&#39;A&#39;)} # hasil dari kondisi 1 else if (x&lt;80 &amp; x &gt;70){ # kondisi 2 print(&#39;B&#39;)} # hasil dari kondisi 2 else{ # kondisi 3 print(&#39;Fail&#39;)} # hasil dari kondisi 3 } ifelse(x) ## [1] &quot;Fail&quot; Dalam tugas Machine Learning, biasanya kita perlu membagi set data antara set rangkaian dan set pengujian. Set kereta memungkinkan algoritma untuk belajar dari data. Untuk menguji kinerja model kita, kita dapat menggunakan set pengujian untuk mengembalikan ukuran kinerja. Basis R tidak memiliki fungsi untuk membuat dua dataset. Kita bisa menulis fungsi kita sendiri untuk melakukan itu. Fungsi kita mengambil dua argumen dan disebut split_data(). Ide di baliknya sederhana, yaitu kita mengalikan panjang dataset (yaitu jumlah observasi) dengan 0,8. Misalnya jika kita ingin membagi dataset 80/20, dan dataset kita berisi 100 baris, maka fungsi kita akan mengalikan 0,8 * 100 = 80. Kemudian kita memiliki 80 baris yang akan dipilih untuk menjadi data pelatihan kita. Kita akan menggunakan dataset air quality untuk menguji fungsi yang ditentukan. Dataset airquality memiliki 153 baris. Kita bisa melihatnya dengan kode di bawah ini: nrow (airquality) ## [1] 153 Ini dia, kita bisa menulis fungsinya. Kita hanya perlu mengubah airquality ke df karena kita ingin mencoba fungsi kita ke dataframe apa pun, tidak hanya airquality: split_data &lt;- function(df, train = TRUE){ length&lt;- nrow(df) total_row &lt;- length *0.75 split &lt;- 1:total_row if (train ==TRUE){ train_df &lt;- df[split, ] return(train_df) } else { test_df &lt;- df[-split, ] return(test_df) } } train &lt;- split_data(airquality, train = TRUE) # membagi untuk training data test &lt;- split_data(airquality, train = FALSE) # membagi untuk testing data dim(train) # mencetak dimensi dari training data ## [1] 114 6 dim(test) # mencetak dimensi dari testing data ## [1] 39 6 Tentu saja, ada banyak package yang dapat Anda gunakan untuk membagi data training dan data testing. Tapi di sini, kita hanya membahas tentang cara membuat sebuah fungsi. Kita akan belajar membagi data training dan mencoba di bab Manipulasi Data. 3.6.2 for Loops (Pengulangan) Dalam pengalaman saya dalam melakukan analisis data, saya menemukan sangat sedikit situasi di mana for loop yang sangat berharga saat kita perlu mengulangi daftar elemen atau rentang angka. Tapi saya beri tahu bahwa, loop dapat digunakan untuk melakukan iterasi pada vektor, matriks, daftar, dataframe, atau objek lainnya. Satu hal yang harus Anda ketahui, R akan mengulang semua variabel dalam vektor dan melakukan komputasi yang tertulis di dalam Expression di bawah ini. For(i in vector){ Expression } Diagram berikut adalah representasi grafis dari langkah-langkah yang dilakukan dalam urutan penyajian aliran algoritma, alur kerja atau proses untuk menguntrol suatu fungsi yang menggunakan kondisi for. Figure 3.3: Diagaram alur for Contoh 1: Mari mengulang semua elemen vektor dan mencetak nilai saat ini. fruit &lt;- c(&#39;Apple&#39;, &#39;Orange&#39;, &#39;Papaya&#39;, &#39;Banana&#39;) # membuat vektor buah for ( i in fruit){ # membuat pernyataan `for` print(i) # hasil } ## [1] &quot;Apple&quot; ## [1] &quot;Orange&quot; ## [1] &quot;Papaya&quot; ## [1] &quot;Banana&quot; Contoh 2: Membuat fungsi non-linier dengan menggunakan polinomial x antara 1 dan 3 dan kita menyimpannya dalam daftar. list &lt;- c() # membuat daftar kosong for (i in seq(1, 3, by=1)) { # membuat pernyataan `for` list[[i]] &lt;- i*i # untuk mengisi daftar } print(list) # hasil ## NULL Contoh 3: Bayangkan kita memiliki df, kita ingin menghitung rata-rata setiap kolom. Anda dapat melakukannya dengan salin dan tempel: set.seed(123) # untuk memastikan kita mendapatkan data yang sama df&lt;- data.frame( # membuat dataframe a = rnorm(10, 5, 1), # vektor `a` dengan bilangan acak normal b = rnorm(10, 5, 1), # vektor `b` dengan bilangan acak normal c = rnorm(10, 5, 1) # vektor `c` dengan bilangan acak normal ) mean(df$a) # menghitung rata-rata dari `a` ## [1] 5.074626 mean(df$b) # menghitung rata-rata dari `b` ## [1] 5.208622 mean(df$c) # menghitung rata-rata dari `c` ## [1] 4.575441 Tapi itu melanggar aturan praktis kita: jangan pernah menyalin dan menempel lebih dari dua kali. Sebagai gantinya, kita bisa menggunakan for loop: output &lt;- vector(&quot;double&quot;, ncol(df)) # membuat daftar kosong for (i in seq_along(df)) { # barisan output[[i]] &lt;- mean(df[[i]]) # tubuh } output # hasil ## [1] 5.074626 5.208622 4.575441 Contoh 4: Sebuah matriks memiliki 2 dimensi, baris dan kolom. Oleh karena itu, untuk melakukan iterasi pada matriks, kita harus mendefinisikan dua for loop, yaitu satu untuk baris dan satu lagi untuk kolom. mat&lt;- matrix(data=seq(11,20,by=1), nrow=5,ncol=2) # membuat matriks for(r in 1:nrow(mat)) # loop dengan r dan c untuk melakukan iterasi pada matriks for (c in 1:ncol(mat)) print(paste(&quot;Row&quot;, r, &quot;and column&quot;,c, &quot;have values of&quot;, mat[r,c])) ## [1] &quot;Row 1 and column 1 have values of 11&quot; ## [1] &quot;Row 1 and column 2 have values of 16&quot; ## [1] &quot;Row 2 and column 1 have values of 12&quot; ## [1] &quot;Row 2 and column 2 have values of 17&quot; ## [1] &quot;Row 3 and column 1 have values of 13&quot; ## [1] &quot;Row 3 and column 2 have values of 18&quot; ## [1] &quot;Row 4 and column 1 have values of 14&quot; ## [1] &quot;Row 4 and column 2 have values of 19&quot; ## [1] &quot;Row 5 and column 1 have values of 15&quot; ## [1] &quot;Row 5 and column 2 have values of 20&quot; mat ## [,1] [,2] ## [1,] 11 16 ## [2,] 12 17 ## [3,] 13 18 ## [4,] 14 19 ## [5,] 15 20 Tantangan Anda: lakukan hal yang sama untuk df seperti yang kami gunakan di atas. Contoh 5: Terkadang Anda ingin menggunakan loop untuk memodifikasi objek yang sudah ada. Misalnya, ingat tantangan kami dari fungsi (Normalisasi). Kami ingin mengubah skala/menormalkan setiap kolom dalam dataframe: set.seed(123) # untuk memastikan kita mendapatkan data yang sama library(tidyverse) # memuat library tidyverse untuk `tibble` ## -- Attaching packages ------------------------------------------------------------------- tidyverse 1.3.0 -- ## v ggplot2 3.3.2 v purrr 0.3.4 ## v tibble 3.0.3 v dplyr 1.0.2 ## v tidyr 1.1.2 v stringr 1.4.0 ## v readr 1.3.1 v forcats 0.5.0 ## -- Conflicts ---------------------------------------------------------------------- tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() df &lt;- tibble( # dataframe menggunakan `tibble` a = rnorm(10, 5, 1), # vektor `a` dengan bilangan acak normal b = rnorm(10, 5, 1), # vektor `b` dengan bilangan acak normal c = rnorm(10, 5, 1) # vektor `c` dengan bilangan acak normal ) rescale &lt;- function(x) { # fungsi ini sama dengan `normalize` rng &lt;- range(x, na.rm = TRUE) (x - rng[1]) / (rng[2] - rng[1]) } for (i in seq_along(df)) { df[[i]] &lt;- rescale(df[[i]]) } df ## # A tibble: 10 x 3 ## a b c ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.236 0.850 0.210 ## 2 0.347 0.620 0.499 ## 3 0.948 0.631 0.225 ## 4 0.448 0.553 0.326 ## 5 0.468 0.376 0.361 ## 6 1 1 0 ## 7 0.579 0.657 0.859 ## 8 0 0 0.626 ## 9 0.194 0.711 0.187 ## 10 0.275 0.398 1 3.6.3 while Loops Terkadang Anda bahkan tidak tahu berapa lama urutan masukan harus berjalan. Ini biasa terjadi saat melakukan simulasi. Misalnya, Anda mungkin ingin mengulang hingga mendapatkan tiga head berturut-turut. Anda tidak dapat melakukan iterasi semacam itu dengan for loop. Sebagai gantinya, Anda dapat menggunakan while loop . While loop lebih sederhana daripada for loop karena hanya memiliki dua komponen, kondisi dan isi. While loop dimulai dengan menguji suatu kondisi. Jika benar, maka mereka mengeksekusi badan dari loop. Setelah badan dari loop dieksekusi, kondisinya diuji lagi, dan seterusnya, hingga kondisinya salah, setelah loop keluar. Sintaks untuk while loop adalah sebagai berikut: while (condition) { Expression } Diagram berikut adalah representasi grafis dari langkah-langkah yang dilakukan dalam urutan penyajian aliran algoritma, alur kerja atau proses untuk menguntrol suatu fungsi yang menggunakan kondisi while. Figure 3.4: Diagaram alur while Contoh 6: Mari kita lihat contoh yang sangat sederhana untuk memahami konsep while loop. Anda akan membuat sebuah loop dan setelah setiap proses menambahkan 2 ke variabel yang disimpan. Anda perlu menutup loop, oleh karena itu kami secara eksplisit memberi tahu R untuk menghentikan perulangan ketika variabel mencapai 11. begin &lt;- 0 # membuat variabel dengan 3 nilai while (begin &lt;= 11){ # mebuat loop cat(&#39;This is loop number&#39;, begin) # untuk melihat yang mana begin &lt;- begin+2 # tambahkan 1 ke variabel dimulai setelah setiap loop print(begin) } ## This is loop number 0[1] 2 ## This is loop number 2[1] 4 ## This is loop number 4[1] 6 ## This is loop number 6[1] 8 ## This is loop number 8[1] 10 ## This is loop number 10[1] 12 Tantangan Anda: lakukan hal yang sama, tetapi dalam kasus ini Anda untuk membuat urutan sepuluh nilai bilangan prima. Contoh 7: While loops dapat berpotensi menghasilkan pengulangan tanpa batas jika tidak ditulis dengan benar. Terkadang akan ada lebih dari satu kondisi dalam pengujian: z &lt;- c(4,5,11) while(z &gt;= 3 &amp;&amp; z &lt;= 10) { coin &lt;- rbinom(1, 1, 0.5) if(coin == 1) { z &lt;- z + 1 } else {z &lt;- z - 1 } } print(z) ## [1] 2 3 9 Kondisi selalu dievaluasi dari kiri ke kanan. Misalnya, dalam kode di atas, jika z kurang dari 3, pengujian kedua tidak akan dievaluasi. 3.6.4 break Loops Pernyataan break yang digunakan untuk melewati/menghentikan iterasi dan mengalirkan kontrol ke luar loop (for, while, repeat). Meskipun, ini tidak umum digunakan dalam aplikasi statistik atau analisis data tetapi ada kegunaannya. Diagram berikut adalah representasi grafis dari langkah-langkah yang dilakukan dalam urutan penyajian aliran algoritma, alur kerja atau proses untuk menguntrol suatu fungsi yang menggunakan kondisi break. Figure 3.5: Diagaram alur break Contoh 8: Mari lakukan iterasi terhadap vektor x,yang memiliki angka berurutan dari 1 sampai 5. Di dalam loop for kita telah menggunakan kondisi if untuk break jika nilai saat ini sama dengan 3. Seperti yang dapat kita lihat dari output, loop berakhir ketika bertemu dengan pernyataan break. x &lt;- 1:5 for (val in x) { if (val == 3){ break } print(val) } ## [1] 1 ## [1] 2 3.6.5 next Loops Pernyataan next berguna ketika kita ingin melewatkan iterasi loop saat segera tanpa menghentikan, terlepas dari iterasi apa yang mungkin dilakukan loop. Figure 3.6: Diagaram alur next Contoh 9: Gunakan pernyataan berikutnya di dalam kondisi untuk memeriksa apakah nilainya sama dengan 3. Jika nilainya sama dengan 3, evaluasi saat ini berhenti (nilai tidak dicetak) tetapi pengulangan berlanjut dengan iterasi berikutnya. x &lt;- 1:5 for (val in x) { if (val == 3){ next } print(val) } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 5 3.6.6 repeat Loops repeat loop digunakan untuk mengulang satu blok kode beberapa kali. Tidak ada pemeriksaan kondisi di loop untuk keluar. Kita sendiri harus menempatkan kondisi secara eksplisit di dalam tubuh loop. Diagram berikut adalah representasi grafis dari langkah-langkah yang dilakukan dalam urutan penyajian aliran algoritma, alur kerja atau proses untuk menguntrol suatu fungsi yang menggunakan kondisi repeat. Figure 3.7: Diagaram alur repeat Contoh 10: Mari gunakan kondisi untuk memeriksa dan keluar dari loop saat \\(x\\) mengambil nilai 6. Oleh karena itu, kita akan melihat dalam output kita bahwa hanya nilai dari 1 hingga 5 yang dicetak. x &lt;- 1 repeat { print(x) x = x+1 if (x == 6){ break } } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 3.7 Fungsi Loop Menulis loop for, while, dll berguna saat memprogram tetapi tidak terlalu sesuai saat bekerja secara interaktif pada baris perintah. Ekspresi multi-garis dengan tanda kurung kurawal tidak begitu nyaman untuk disortir saat mengerjakan. R memiliki beberapa fungsi yang mengimplementasikan perulangan dalam bentuk yang ringkas untuk mempermudah pekerjaan anda sebagai data scientist. tapply() Fungsi berguna di atas subset vektor lapply() Ulangi daftar dan evaluasi fungsi pada setiap elemen sapply() Sama seperti lapply tetapi coba menyederhanakan hasilnya apply() Fungsi yang berguna di atas margin array mapply() Versi multivariasi dari lapply Catatan: Perulangan (looping) sebenarnya dilakukan secara internal dalam kode C untuk alasan efisiensi. 3.7.1 tapply() tapply() digunakan untuk menerapkan fungsi di atas subset vektor. Ini dapat dianggap sebagai kombinasi split() dan sapply() untuk vektor saja. Saya telah diberi tahu bahwa “t” di tapply() mengacu pada “tabel”, tapi itu belum dikonfirmasi. str (tapply) ## function (X, INDEX, FUN = NULL, ..., default = NA, simplify = TRUE) Argumen untuk tapply() adalah sebagai berikut: * X adalah vektor * INDEX adalah faktor atau daftar faktor (atau mereka dipaksa menjadi faktor) * FUN adalah fungsi yang akan diterapkan * ... berisi argumen lain untuk dilewatkan FUN * simplify haruskah kita menyederhanakan hasilnya? Contoh 11: Untuk memahami cara kerjanya, mari gunakan dataset iris. Dataset ini sangat terkenal di dunia pembelajaran mesin. Tujuan dari dataset ini adalah untuk memprediksi kelas dari masing-masing dari tiga spesies bunga: Sepal, Versicolor, Virginica. Dataset mengumpulkan informasi untuk setiap spesies tentang panjang dan lebarnya. data(iris) # memuat dataset `iris` tapply(iris$Sepal.Width, iris$Species, mean) # rata-rata lebar tiap spesies ## setosa versicolor virginica ## 3.428 2.770 2.974 Kita juga dapat mengambil rata-rata grup tanpa menyederhanakan hasilnya, yang akan memberi kita daftar (list). Untuk fungsi yang mengembalikan nilai tunggal, biasanya ini bukan yang kita inginkan, tapi bisa dilakukan. tapply (iris$Sepal.Width, iris$Species, mean, simplify = F) ## $setosa ## [1] 3.428 ## ## $versicolor ## [1] 2.77 ## ## $virginica ## [1] 2.974 3.7.2 lapply() Fungsi ini berguna untuk melakukan operasi pada objek daftar dan mengembalikan objek daftar dengan panjang yang sama dari set aslinya. Ini akan mengembalikan daftar dengan panjang yang sama sebagai objek daftar masukan, yang masing-masing elemennya merupakan hasil dari penerapan FUN ke elemen daftar (list) yang sesuai. Contoh 12: Gunakan fungsi mean() untuk semua elemen daftar. Jika daftar asli memiliki nama, nama-nama tersebut akan dipertahankan di dalam output. lapply(df, mean) # ambil mean dari setiap kolom `df` ## $a ## [1] 0.4495403 ## ## $b ## [1] 0.5795182 ## ## $c ## [1] 0.4292232 Contoh 13: Ubah nilai string matriks menjadi huruf kecil dengan fungsi tolower. Kita membuat matriks dengan nama film terkenal. Nama dalam format huruf besar. movies &lt;- c(&quot;FOUNDATION&quot;, &quot;AVENGERS&quot;, &quot;HAMILTON&quot;, &quot;CHINATOWN&quot;) # membuat vektor film terkenal movies_lower &lt;-lapply(movies, tolower) # huruf kecil dengan fungsi `tolower` str(movies_lower) # mari lihat hasilnya ## List of 4 ## $ : chr &quot;foundation&quot; ## $ : chr &quot;avengers&quot; ## $ : chr &quot;hamilton&quot; ## $ : chr &quot;chinatown&quot; movies_lower &lt;-unlist(lapply(movies,tolower)) # `unlist()` untuk mengonversi daftar menjadi vektor str(movies_lower) ## chr [1:4] &quot;foundation&quot; &quot;avengers&quot; &quot;hamilton&quot; &quot;chinatown&quot; 3.7.3 sapply() Fungsi sapply() berperilaku mirip dengan lapply(); satu-satunya perbedaan nyata adalah pada nilai pengembaliannya. sapply() akan mencoba menyederhanakan hasil dari lapply() jika memungkinkan. Pada dasarnya, sapply() memanggil lapply() pada inputnya dan kemudian menerapkan algoritma berikut: Jika hasilnya adalah daftar (list) di mana setiap elemen memiliki panjang 1, maka vektor dikembalikan Jika hasilnya adalah daftar (list) di mana setiap elemen adalah vektor dengan panjang yang sama (&gt;1) , matriks dikembalikan. Jika tidak bisa memahaminya, daftar (list) dikembalikan sapply(df, mean) # ambil rata-rata (mean) dari setiap kolom `df` ## a b c ## 0.4495403 0.5795182 0.4292232 3.7.4 apply() Fungsi apply() mengambil dataframe atau matriks sebagai masukan dan memberikan keluaran dalam vektor, daftar atau larik (array). Ini juga terutama digunakan untuk menghindari penggunaan eksplisit dari konstruksi perulangan. Selain itu, fungsi ini adalah yang paling dasar dari semua fungsi loop yang dapat digunakan melalui matriks. Fungsi ini membutuhkan 3 argumen: str (apply) ## function (X, MARGIN, FUN, ...) Argumen untuk apply() adalah X adalah sebuah array (bisa berupa data frame, list, vector, dll) MARGIN adalah vektor integer yang menunjukkan margin mana yang harus “dipertahankan”. FUN adalah fungsi yang akan diterapkan ... adalah untuk argumen lain yang akan diteruskan ke FUN Contoh 11: Mari buat matriks 20 kali 10 dari bilangan acak Normal. Kemudian hitung rata-rata setiap baris. Anda juga dapat menghitung jumlah setiap kolom. x &lt;- matrix(rnorm(200), 20, 10) # membuat matriks dari bilangan acak normal apply(x, 1, mean) # ambil rata-rata setiap baris ## [1] 0.21452704 0.01402182 -0.34294835 0.63594319 0.03130845 -0.11024589 ## [7] 0.03889518 -0.71010056 0.14139433 0.08666582 -0.50437598 0.33027642 ## [13] -0.22247429 -0.20311274 -0.06158189 -0.25914127 0.59408006 0.14762331 ## [19] 0.44863380 -0.00668331 apply(x, 2, sum) # ambil rata-rata dari setiap kolom ## [1] 3.2266692 0.4227250 3.8438758 -1.0968217 -2.4700750 -4.7423030 ## [7] 2.4712386 0.4738987 0.9137009 -0.4158571 Anda mungkin telah memperhatikan bahwa argumen kedua MARGIN adalah 1 atau 2, bergantung pada apakah kita menginginkan statistik baris atau statistik kolom. Sebenarnya, ada beberapa kasus khusus dari jumlah kolom/baris dan rata-rata matriks kolom/baris, kita memiliki beberapa cara pintas yang berguna. rowSums = apply(x, 1, sum) rowMeans = apply(x, 1, mean) colSums = apply(x, 2, sum) colMeans = apply(x, 2, mean) Contoh 12: Melihat kembali masalah normalisasi, kita bisa menyelesaikannya dengan cara yang lebih sederhana menggunakan apply(): normalize &lt;- function(x){ norm &lt;- (x-min(x))/(max(x)-min(x)) return(norm) } apply(df, 2, normalize) ## a b c ## [1,] 0.2364281 0.8500528 0.2104635 ## [2,] 0.3472617 0.6197981 0.4994777 ## [3,] 0.9475335 0.6307099 0.2246853 ## [4,] 0.4481587 0.5534256 0.3257267 ## [5,] 0.4678825 0.3758531 0.3610444 ## [6,] 1.0000000 1.0000000 0.0000000 ## [7,] 0.5791625 0.6565733 0.8585184 ## [8,] 0.0000000 0.0000000 0.6257648 ## [9,] 0.1940214 0.7107903 0.1865516 ## [10,] 0.2749546 0.3979789 1.0000000 3.7.5 mapply() Fungsi mapply() adalah penerapan multivariasi jenis yang menerapkan fungsi secara paralel pada sekumpulan argumen. Ingat bahwa lapply() dan teman-teman hanya melakukan iterasi pada satu objek R. Bagaimana jika Anda ingin mengulang beberapa objek R secara paralel? Inilah gunanya mapply(). str(mapply) ## function (FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE) Argumen untuk mapply() adalah: FUN adalah fungsi untuk diterapkan ... berisi objek R untuk diterapkan MoreArgs adalah daftar argumen lain untuk FUN SIMPLIFY menunjukkan apakah hasil harus disederhanakan Fungsi mapply() memiliki urutan argumen yang berbeda dari lapply() karena fungsi yang akan diterapkan lebih dulu daripada objek yang akan diiterasi. Objek R di mana kita menerapkan fungsi yang diberikan dalam argumen ... karena kita dapat menerapkan sejumlah objek R. Contoh 13: Buat daftar yang berulang list(rep(1,4), rep(2,3), rep(3,2), rep(4,1)) mapply(rep, 1:4, 4:1) ## [[1]] ## [1] 1 1 1 1 ## ## [[2]] ## [1] 2 2 2 ## ## [[3]] ## [1] 3 3 ## ## [[4]] ## [1] 4 Contoh 14: Membuat simulasi variabel Normal acak. noise &lt;- function(n, mean, sd) { rnorm(n, mean, sd) } noise(5, 1, 2) # Simulasikan 5 bilangan acak ## [1] 1.4290777 -0.4770554 -0.1487774 -1.6340323 0.6341492 apply(x, 2, sum) # Ambil mean dari setiap kolom ## [1] 3.2266692 0.4227250 3.8438758 -1.0968217 -2.4700750 -4.7423030 ## [7] 2.4712386 0.4738987 0.9137009 -0.4158571 noise(1:5, 1:5, 2) # Ini hanya mensimulasikan 1 set angka, bukan 5 ## [1] 1.837965 2.648609 1.436927 2.422756 3.995603 # dapatkan 5 set bilangan acak, # masing-masing dengan panjang dan rata-rata yang berbeda mapply(noise, 1:5, 1:5, 2) ## [[1]] ## [1] 3.992121 ## ## [[2]] ## [1] -0.2746072 1.6418968 ## ## [[3]] ## [1] 6.8047236 2.7980502 0.2803186 ## ## [[4]] ## [1] 2.670461 4.970920 3.248794 2.876247 ## ## [[5]] ## [1] 4.312166 5.180993 8.197018 4.822870 7.161599 "]
]
